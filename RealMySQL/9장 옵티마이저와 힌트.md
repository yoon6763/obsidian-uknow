```table-of-contents
```

# 9.1 개요

어느 DBMS든지 쿼리의 실행 계획을 수립하는 옵티마이저는 가장 복잡하다.
옵티마이저가 만든 실행 계획을 이해하는 것도 상당히 어렵다.
하지만 실행 계획을 이해해야 실행 계획의 불합리한 부분을 찾고
더 최적화된 실행 계획을 세우도록 유지할 수 있다.


## 9.1.1 쿼리 실행 절차

mysql 서버에서 쿼리가 실행되는 과정은 크게 3가지로 나눌 수 있다.
1. 사용자로부터 요청된 SQL 문장을 자게 쪼개 MySQL 서버가 이애할 수 있는 수준으로 분리(파스 트리)
	*  파싱(Parsing)이라 함
	* sql 파서 모듈로 처리
2. SQL의 파싱 정보(파스 트리)를 확인하며 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
	* 불필요한 조건 제거 및 복잡한 연산 단순화
	* 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블 읽을지 결정
	* 각 테이블의 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
	* 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야 하는지 결정
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴



## 9.1.2 옵티마이저의 종류

옵티마이저는 DB 서버에서 두뇌와 같은 역할
대부분 DBMS에서 옵티마이저는 #비용_기반_최적화_Cost-based-optimizer, CBO)를 선택하고 있으며,
초기 버전 오라클 DBMS에서 많이 사용하는 #규칙_기반_최적화_방법_Rule-based-optimizer, RBO)도 있음

* 규칙 기반 최적화
	* 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립
	* 통계 정보를 조사하지 않고 실행 계획 수립 -> 같은 쿼리에는 거의 항상 같은 실행 방법을 만듬
	* 하지만 사용자의 데이터 분포가 매우 다양하므로 이미 오래전부터 많은 DBMS에서는 거의 사용하지 않음

* 비용 기반 최적화
	* 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만듬
	* 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출
	* 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리 실행


현재 대부분의 RDBMS가 비용 기반 옵티마이저 채택 (mysql 포함)



# 9.2 기본 데이터 처리

모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등 기본 데이터 가공 기능을 가짐
하지만 결과물은 동일하더라도 RDBMS별로 그 결과를 만들어내는 과정은 천차만별



## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔은 이름처럼 인덱스를 사용하지 않고 테이블 전체를 읽는 작업이다
mysql 옵티마이저는 다음과 같은 조건일 떄 주로 풀 테이블 스캔을 선택한다

* 테이블의 레코드 건수가 너무 작어서 인덱스를 통해 읽는 것 보다 풀 테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
* WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 있는 경우
* 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

일반적으로 테이블 전체 크기는 인덱스보다 훨씬 크다!
즉, 테이블을 처음부터 끝까지 풀 스캔 때리면 상당히 많은 디스크 읽기가 필요하다

그렇다면 어떻게 해야할까?
한꺼번에 여러 개 블록이나 페이지를 읽어오는 것이다.

하지만 mysql에는 풀 테이블 스캔 시 한꺼번에 몇 개씩 페이지를 읽어올지 설정하는 시스템 변수는 없다. 때문에 많은 사람들이 mysql은 풀 스캔할 때 디스크로부터 페이지를 하나씩 읽어 오는 것으로 생각한다 -> 반은 맞고 반은 틀리다.
myisam에서는 맞지만 innodb에서는 틀리다.
innodb에서는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 실행된다

#리드_어헤드 : 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전 미리 디스크에서 읽어 innodb의 버퍼 풀에 가져다 두는 걸 의미



# 9.2.2 병렬 처리


> 여기서 말하는 병럴 처리는 하나의 쿼리를 여러 스레드가 작업을 나눠 동시에 처리하는 걸 의미, 여러 개 쿼리를 동시에 처리하는 것이 아님


innodb_pararell_read_threads 시스템 변수로 하나의 쿼리를 최대 몇 개의 스레드를 이용해 처리할 지 변경 가능



