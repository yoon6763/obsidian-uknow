
# 8.4 R-Tree 인덱스

#공간_인덱스  R-Tree 인덱스 알고리즘을 이용해 2차원 데이터를 인덱싱하고 검색하는 목적의 인덱스이다
내부 매커니즘은 B-Tree와 흡사하다. 다만 1차원과 2차원이라는 점이 다르다.

GPS나 지도 서비스 내장 스마트폰이 대중화되면서 SNS 서비스가 GIS, GPS 기반 서비스로 확장되고 있다.
위치 기반 서비스 구현 방법은 여러 가지가 있지만 MySQL 공간 확장을 이용하면 간단히 구현 가능 하다.
* 공간 데이터를 저장할 수 있는 데이터 타입
* 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
* 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

## 8.4.1 구조 및 특성

![[Pasted image 20240703223024.png]]

MySQL은 공간 정보의 저장 및 검색을 위해 여러 기하학적 도형(Geometry) 정보를 관리할 수 있는 데이터 타입을 제공한다.

R-Tree 알고리즘을 이해하려면 MBR(Minimun Bounding Rectangle)에 대한 이해가 필요하다.
해당 도형을 감싸는 최소 크기의 직사각형을 의미하며, 이 사각형들의 포함 관계를 B-Tree 형태로 구현한 인덱스가 R-Tree 인덱스이다

![[Pasted image 20240703223129.png]]




![[Pasted image 20240703223231.png]]![[Pasted image 20240703223245.png]]


위 그림을 3가지 레벨로 나누면 아래 그림과 같다

* 최상위 레벨 : R1, R2
* 차상위 레벨 : R3, R4, R5, R6
* 최하위 레벨 : R7 ~ R14



## 8.4.2 R-Tree 인덱스의 용도

B-Tree에 Rectangle의 'R'이 섞여 R-Tree라는 이름이 붙여졌으며,
공간(Spatial) 인덱스라고도 한다.

일반적으로 WGS84(GPS) 기준 위도, 경도 좌표 저장에 주로 사용되며 CAD/CAM 소프트웨어 또는 회로 디자인 등과 같이 좌표 시스템에 기반을 둔 정보에 대해서는 모두 적용을 할 수 있다.




# 8.4 전문 검색 인덱스

지금까지 알아본 인덱스 알고리즘은 일반적으로 크지 않은 데이터 + 이미 키워드화한 작은 값에 대한 인덱싱 알고리즘이다
B-Tree인덱스는 실제 칼럼의 값이 1MB이더라도 1MB 전체의 값을 인덱스 키로 사용하는게 아닌, 1000바이트(myisam) 또는 3072(innodb)바이트까지만 잘라 인덱스 키로 사용한다.
또한, B-Tree 인덱스의 특성에서도 알아봤듯 전체 일치 또는 좌측 일부 일치와 같은 검색만 가능하다.

때문에 문서 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문 (Full Text) 검색에는 innodb, myisam에서 제공하는 일반 용도의 B-Tree 인덱스 사용이 불가능하다.

이런 상황에서 사용할 수 있는게 전문 검색 인덱스라 한다.



## 8.5.1 인덱스 알고리즘

문서 본문의 내용에서 사용자가 검색하게 될 키워드 분석 + 빠른 검색용으로 사용할 수 있게 이러한 키워드로 인덱스를 구축한다

### 8.5.1.1 어근 분석 알고리즘

mysql 서버의 전문 검색 인덱스는 다음과 같은 두 가지 과정으로 색인 작업이 수행된다
* 불용어 처리(stop word)
	* 별 가치 없는 단어를 모두 필터링
	* 개수가 많지 않아 코드에 모두 상수로 정의해서 사용하곤 함
	* 유연성을 위해 불용어 자체를 데이터베이스화해서 추가/삭제하는 경우도 있음
* 어근 분석(stermming)
	* 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업
	* 한글이나 일본어는 영어와 같이 단어 변형 자체는 거의 없기 때문에 어근 분석보다는 문장의 형태소를 분석해서 명사와 조사를 구분하는 기능이 더 중요


### 8.5.1.2 n-gram 알고리즘

형태소 분석이 문장을 이해하는 알고리즘이라면, n-gram은 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘이다.

무조건 몇 글자씩 잘라서 인덱싱하는 방법으로,
형태소 분석보다는 단순 + 국가별 언어에 대한 이해와 준비 과정이 필요 없다
단, 만들어지는 인덱스 크기가 상당히 큰 편
n-gram에서 n은 인덱싱할 최소 글자 수를 의미
일반적으로는 (n=2)인 2-gram(Bi-gram)이 많이 사용

| To be or not to be. That is the question
띄어쓰기와 마침표(.) 기준으로 10개 단어로 구분
2글자씩 중첩해서 토큰으로 분리

![[Pasted image 20240703224621.png]]




## 8.5.2 전문 검색 인덱스의 가용성

전문 검색 인덱스를 사용하려면 반드시 아래 두 조건을 갖춰야한다
* 쿼리 문장이 전문 검색을 위한 문법 (MATCH ... AGAINST ...)을 사용
* 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스를 보유

```
CREATE TABLE tb_test (
		doc_Id INT,
		doc_body TEXT,
		PRIMARY KEY (doc_id),
		FULLTEXT KEY fx_docbody (doc_body) WITH PARSER ngram
) ENGINE=InnoDB;

```

위와 같이 전문 인덱스를 생성했다고 하자

```
SELECT * FROM tb_test WHERE doc_body LIKE '%애플%';
```

위와 같은 쿼리로도 원하는 검색 결과를 얻을 수 있다.
하지만 전문 검색 인덱스를 이용한게 아니라 테이블을 처음부터 끝까지 풀 스캔 때린거다


```
SELECT * FROM tb_test WHERE MATCH(doc_body) AGAINST('애플'IN BOOLEAN MODE);

```


MATCH, AGAINST 구문으로 쿼리를 작성하여 전문 검색 인덱스를 사용하였다.



# 8.6 함수 기반 인덱스

일반적인 인덱스는 칼럼의 값 일부(칼럼 값 앞부분) 또는 전체에 대해 인덱스 생성이 허용되는데,
때로는 칼럼의 값을 변형하여 만들어진 값에 대해 인덱스를 구축해야 할 때도 있다.

이러한 경우 함수 기반 인덱스가 좋은 방법이다.
8.0 부터 지원하기 시작했으며, 아래 두 가지로 함수 기반 인덱스를 구현할 수 있다.
* 가상 칼럼을 이용한 인덱스
* 함수를 이용한 인덱스

함수 기반 인덱스는 인덱싱 값 계산 과정 차이만 있고
실제 인덱스 내부 구조 및 유지관리 방법은 B-Tree 인덱스와 동일하다


## 8.6.1 가상 칼럼을 이용한 인덱스

```
CREATE TABLE user (
		user_id BIGINT,
		first_name VARCHAR(10),
		last_name VARCHAR(10),
		PRIMARY_KEY (user_id)
);
```


위 테이블에서 first_name과 last_name을 합쳐 검색해야 하는 요건이 생겼다면
mysql 서버에 full_name 컬럼을 추가하고 모든 레코드에 대해 full_name을 업데이트 하는 작업을 거쳐야 했다.


```
ALTER TABLE user
	ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
	ADD INDEX ix_fullname (full_name);
```

하지만 8.0 버전부터는 가상 칼럼을 추가하고 그 가상 칼럼에 인덱스를 생성할 수 있게 되었다!

![[Pasted image 20240703225424.png]]

full_name 칼럼에 대한 검색도 새로 만들어진 ix_fullname 인덱스를 활용하여 실행 계획이 만들어진다.



## 8.6.2 함수를 이용한 인덱스

```
CREATE TABLE user (
		user_id BIGINT,
		first_name VARCHAR(10),
		last_name VARCHAR(10),
		PRIMARY_KEY (user_id),
		INDEX ix_fullname ((CONCAT(first_name, ' ', last_name))
);
```

8.0 버전부터 위와 같이 테이블 구조를 변경하지 않고 함수를 직접 사용하는 인덱스를 생성할 수 있게 됬다

함수를 직접 사용하는 인덱스는 테이블 구조를 변경 X, 계산된 결과값의 검색을 빠르게 만들어준다
또한, 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용되어야 한다.


# 8.7 멀티 밸류 인덱스

전문 검색 인덱스 제외 모든 인덱스는 레코드 1건이 1개 인덱스 키 값을 가진다. 즉 인덱스 키와 데이터 레코드는 1:1 관계이다.

하지만 멀티 밸류 인덱스는 이름에서 볼 수 있듯 하나의 데이터 레코드가 여러 개 키 값을 가질 수 있는 1:N 형태 인덱스이다

그럼 머리속에 한 가지 생각이 지나쳐갈 수도 있다 '이거 정규화 위반 아닌가..?'
맞다.
하지만 최근 RDBMS들이 JSON 데이터 타입을 지원하기 시작하면서
JSON 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생했다.

mongoDB의 경을 애초에 json 포맷으로 데이터 저장하니 처음부터 일너 형태 인덱스를 지원했으나
mysql 서버는 멀티 밸류 인덱스에 대한 지원 없이 json 타입 칼럼만 지원했다.
하지만 배열 형태에 대한 인덱스 생성이 되지 않아 mongodb와 많이 비교되곤 했고
8.0 버전부터 업그레이드되어 태생적으로 json을 사용한 mongodb에 비교해도 부족함이 없게 되었다

```
// 멀티 밸류 인덱스 생성
CREATE TABLE user (
    user_id BIGINT AUTO_INCREMENT PRIMARY KEY, 
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    credit_info JSON,
    INDEX mx_creditscores (
        (CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY))
    )
);

// INSERT
INSERT INTO user VALUES (1, 'Matt', 'Lee1', '{"credit.scores":[360, 353, 351]}');
```

멀티 밸류 인덱스를 활용하기 위해서는
반드시 다음 함수들을 사용해야 옵티마이저가 인덱스를 활용한 실행 계획을 세운다
* MEMEBER OF()
* JSON_CONTAINS()
* JSON_OVERLAPS()



# 8.8 클러스터링 인덱스

클러스터링이란 여러 개를 하나로 묶는다는 의미이다.
인덱스 클러스터링도 위 의미를 크게 벗어나지 않는다.

## 8.8.1 클러스터링 인덱스

클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용된다
프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며,
프라이머리 키 값이 변경되면 그 레코드의 물리적 저장 위치가 바뀌여야 한다는 의미이기도 함

프라이머리 키 값으로 클러스터링된 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 크므로
신중히 프라이머리 키 값을 결정해야 한다

pk 값에 의해 레코드 저장 위치가 결정되다보니 사실 인덱스 알고리즘 보다는 데이터 레코드 저장 방식으로 볼 수 있다.
-> 때문에 '클러스터링 인덱스'와 '클러스터링 테이블'은 동의어로 사용되기도 한다

클러스터링 기준이 되는 프라이머리 키는 클러스터링 키라고도 하며
innodb와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 pk 기반 검색이 매우 빠르나, 저장 및 변경이 상대적으로 느리다.
일반적인 B-Tree도 키 값으로 정렬되어 저장되지만 클러스터링 인덱스는 테이블의 레코드가 pk 값으로 정렬되어 저장된다.


프라이머리 키가 없을 경우도 있다. 그렇다면 해야 할까?
1. 프라이마러 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
2. NOT NULL + UNIQUE INDEX 중 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가 후 클러스터링 키로 선택



## 8.8.2 세컨더리 인덱스에 미치는 영향

myisam, memory 테이블 같은 클러스터링되지 않은 테이블은 insert 시 저장 공간에서 이동하지 않는다. ROWID로 실제 데이터 레코드를 찾는다.
innodb에서는 인덱스가 실제 레코드의 주소를 가진다면 키 값이 변경될 때 마다 데이터 레코드의 주소가 변경되고, 해당 테이블의 그 때 마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 할 것이다.

이런 오버헤드를 제거하기 위해 innodb 테이블 (클러스터링 테이블)의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어 있다.



## 8.8.3 클러스터링 인덱스의 장점과 단점

myisam같은 클러스터링되지 않은 일반 프라이머리 키와 클러스터링 인덱스를 비교했을 때 상대적 장단점이다.

 장점
* pk(클러스터링 키)로 검색 시 처리 성능이 매우 빠름(특히 프라이머리 키를 범위 검색하는 경우 매우 빠름)
* 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있으므로 인덱스만으로 처리될 수 있는 경우가 많음 (이를 커버링 인덱스라 함)

단점
* 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
* 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한 번 검색해야 하므로 처리 성능이 느림
* insert 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
* 프라이머리 키를 변경될 때 레코드를 delete 하고 insert 하는 작업이 필요하기 때문에 처리 성능이 느림

요약하자면 장점은 바른 읽기(select) 이며 단점은 느린 쓰기 (insert, update, delete)이다.
일반적으로 웹 서비스와 같은 온라인 트랜잭션 환경에서는 쓰기와 읽기 비율이 2:8 ~ 1:9이기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 하는게 매우 중요



## 8.8.4 클러스터링 테이블 사용 시 주의사항

### 8.8.4.1 클러스터링 인덱스 키의 크기

클러스터링 테이블은 모든 세컨더리 인덱스가 프라이머리 키(클러스터링 키) 값을 포함한다.
프라이머리 키 크기가 커지면 인덱스도 자동으로 커진다.

하지만 일반적으로 테이블에 세컨더리 인덱스가 4~5개 정도 생성된다는 걸 고려하면 세컨더리 인덱스 크기는 급격하게 증가한다.

인덱스가 커질수록 같은 성능을 내기 위해 그만큼 메모리가 더 필요하니,
innodb 프라이머리 키는 신중하게 선택하자.


### 8.8.4.2 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성(가능한 경우)

pk키는 클러스터링 키로 사용되며 이 값에 의해 레코드의 위치가 결정된다.
pk로 검색하는 경우 클러스터링되지 않은 테이블에 비해 매우 빠르단걸 의미한다

myisam 같은 클러스터링되지 않는 테이블에서는 pk로 뭘 선택하든 유의미한 차이는 나지 않을 수 있으나
innodb에서는 겁나크니까 꼭 의미있는 칼럼을 선택하자


### 8.8.4.3 프라이머리 키는 반드시 명시할 것

가끔 pk가 없는 테이블을 보게 된다. 가능하면 AUTO_INCREMENT 칼럼을 써서라도 프라이머리 키 생성을 권장한다.
pk가 없다면 내부적으로 일련번호 컬럼을 생성한다. 이는 사용자에게 보이지 않아 사용할 수 없다.
결국 AUTO_INCREMENT와 똑같다는 이야기다.
때문에, 차라리 사용자가 사용가능한 AUTO_INCREMENT라도 pk 생성을 권장한다


### 8.8.4.4 AUTO-INCREMENT 칼럼을 인조 식별자로 사용하는 경우

여러 칼럼이 복합으로 pk를 만드는 경우 pk 크기가 가끔 길어진다.
하지만 pk 크기가 길어도 세컨더리 인덱스가 필요치 않다면 그대로 pk를 사용하는게 좋다
세컨더리 인덱스도 필요하고 pk 크기도 길다면 AUTO_INCREMENT 칼럼을 추가하고 이를 pk로 쓰자

이와같이 pk를 대체하기 위해 인위적으로 추가한 pk를 인조 식별자(Surrogate key)라 한다

로그 테이블처럼 조회보단 insert 위주라면 AUTO_INCREMENT를 이용한 인조 식별자를 pk로 두는게 성능 향상에 도움이 된다.



# 8.9 유니크 인덱스

유니크는 사실 인덱스 보단 제약 조건에 가깝다.
말 그대로 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없는 걸 의미하기 때문이다.

mysql에서는 인덱스 없이 유니크 제약만 설정할 수 있는 방법이 없다.
유니크 인덱스에서 null도 저장될 수 있는데 null값은 특정 값이 아니므로 2개 이상 저장될 수 있다.

때문에 mysql pk는 기본적으로 null을 허용하지 않는 유니크 속성이 자동부여된다


## 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스의 구조상 아무런 차이점이 없다
읽기와 쓰기를 성능 관점에서 한 번 살펴보자


### 8.9.1.1 인덱스 읽기

유니크 인덱스가 빠르다 생각할 수 있으나, 사실이 아니다.

유니크 인덱스는 1건만 읽으면 되지만 유니크하지 않은 세컨더리 인덱스에서는 레코드를 한 건 더 읽어야 하므로 느리다?
하지만 유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아닌 CPU에서 칼럼값 비교이므로 성능상 영향이 거의 없다.


### 8.9.1.2 인덱스 쓰기

유니크 인덱스는 쓰기 작업을 할 때 중복 체크과정이 한 단계 더 필요하므로 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.
또한, mysql에서 유니크 인덱스에서 중복 값 체크 시 읽기 잠금 사용, 쓰기 시 쓰기 잠금을 사용하는데 이 과정에서 데드락이 빈번하게 발생
innodb에는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼가 사용되어 저장, 변경 작업이 상당히 빨리 처리된다. 하지만 유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링하지는 못하기에 유니크 인덱스는 일반 세컨더리 인덱스보다 변경 작업이 더 느리게 작동한다.




# 8.10 외래키

mysql에서 외래키는 innodb 스토리지 엔진에서만 생성할 수 있다
외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼 인덱스까지 생성된다
외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다

innodb 외래키 관리에는 중요한 두 가지 특성이 있다
* 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다
* 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다


```
CREATE TABLE parent (
		id INT NOT NULL,
		address VARCHAR(100) NOT NULL, PRIMARY KEY (id)
) ENGINE=InnoDB;

CREATE TABLE child (
		id INT NOT NULL,
		pid INT DEFAULT NULL,
		address VARCHAR(100) NOT NULL,
		PRIMARY KEY (id),
		KEY ix_parentid (pid),
		CONSTRAINT child_ibfk_1 FOREIGN KEY (pid) REFERENCES to_parent (id) ON DELETE CASCADE
) ENGINE=InnoDB;

INSERT INTO tb_parents VALUES (1, 'parent-1'), (2, 'parent-2');
INSERT INTO tb_child VALUES (100, 1, 'child-100');
```


위와 같은 테이블에서 언제 자식 테이블의 변경이 잠금 대기를 하고,
언제 부모 테이블의 변경이 잠금 대기를 하는지 알아보자



## 8.10.1 자식 테이블의 변경이 대기하는 경우

![[Pasted image 20240704183156.png]]


1. 1번 커넥션에서 먼저 트랜잭션 시작
2. 부모(th_parent) 테이블에서 id가 2인 레코드에 쓰기 잠금 흭득
3. 2번 커넥션에서 자식 테이블(th_child)의 외래키 칼럼을 pid = 2로 변경하는 쿼리 실행
	1. 이 쿼리는 부모 테이블의 변경 작업이 완료될 때까지 대기
4. 1번 커넥션에서 ROLLBACK이나 COMMIT으로 트랜잭션 종료 시 2번 커넥션의 대기 중이던 작업이 즉시 처리되는 걸 볼 수 있다

즉 자식 테이블의 외래 키 칼럼의 변경(insert, update)는 부모 테이블의 확인이 필요한데,
이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때 까지 기다리는 것이다.



## 8.10.2 부모 테이블의 변경 작업이 대기하는 경우


![[Pasted image 20240704185321.png]]


1. 1번 커넥션에서 부모 키 '1'을 참조하는 자식 테이블의 레코드를 변경하면 th_child 테이블의 레코드에 대해 쓰기 잠금 흭득
2. 이 상태에서 2번 커넥션이 tb_parent 테이블에서 id가 1인 레코드를 삭제하는 경우 이 쿼리(작업번호 4번)는 th_child 테이블의 레코드에 대한 쓰기 잠금이 해제될 때 까지 기다려야 함


자식 테이블이 생성될 때 외래키 특성이 on delete cascade로 지정됬기 때문에
부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되는 식으로 작동되기 때문이다



db에서 물리적으로 외래키를 생성하려면 잠금 경합까지 고려해 모델링을 진행하는게 좋다.
물리적으로 외래키 생성 시 자식 테이블에 레코드가 추가되는 경우
해당 참조키가 부모 테이블에 있는지 확인한다.
하지만 물리적인 외래키 고려 사항은 이런 체크 작업보다는, 체크를 위해 테이블에 읽기 잠금을 걸어야 한다는 것이다.
또한 이렇게 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리 동시 처리에 영향을 미친다.