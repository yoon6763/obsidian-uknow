```table-of-contents
```


5장은 MySQL의 동시성에 영향을 미치는 잠금(Lock), 트랜잭션, 격리 수준(Isolation Level)에 관한 이야기이다.
이야기 보따리를 풀어보자.



# 5.1 트랜잭션

트랜잭션은 존재 자체가 개발자에게 큰 혜택이다.


## 5.1.1 MySQL에서의 트랜잭션

트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합됬을 때에만 의미있는 게 아니다.
하나의 논리적인 작업 셋에 하나든, 두 개 이상이든 상관없이
작업 셋 자체가 100% 적용(commit 실행됬을 때) 되거나 아무것도 적용되지 않아야 (rollback) 함을 보장한다.


![[Pasted image 20240529003538.png]]

비교를 위해 트랜잭션을 지원하지 않는 myisam과 트랜잭션을 지원하는 innodb에 각각 레코드를 저장해보자.


![[Pasted image 20240529003653.png]]

auto-commit을 on 한 뒤, 위 문장을 각 스토리지 엔진에서 실행해보자.


![[Pasted image 20240529003721.png]]
![[Pasted image 20240529003726.png]]


두 insert 모두 프라이머리 키 중복으로 쿼리가 실패했다고 뜬다.
하지만 myisam에서 조회를 해보면 오류가 발생했음에도 '1', '2'는 insert 된 상태로 남아있다.
즉, insert 문장이 1, 2를 저장하고 3을 저장하면서 오류가 발생했지만,
**이미 insert 된 1, 2는 그대로 두고 쿼리를 종료했기 때문이다!!!!**

즉, 트랜잭션은 골치 아픈 기능 정도로 생각할 수 있지만,
없으면 훨씬 골치 아픈 상황이 나타날 수도 있는 것이다.




## 5.1.2 주의사항

* 트랜잭션 또한 DBMS 커넥션과 비슷하게 최소의 코드에만 적용
	* = 트랜잭션의 범위를 최소화하라는 의미


1. 처리시작
	 -> 데이터베이스 커넥션 생성
	 -> 트랜잭션 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
9. 알림 메일 발송 이력을 DBMS에 저장
    <- 트랜잭션 종료 (commit)
    <- 데이터베이스 커넥션 반납
10. 처리 완료

* 트랜잭션이 필요한 C,U,D는 5번부터 시작이기에 2,3,4를 트랜잭션에 포함시킬 필요는 없음
* 8번은 메일전송/FTP 등 네트워크 통신 작업이기에 DBMS 트랜잭션에서 제거하는게 좋음
	* 메일 서버와 통신할 수 없는 상황이 발생하면 웹 서버와 DBMS 서버까지 위험해질 수 있기 때문


**보완하여 재설계한 절차

1. 처리 시작
2. 로그인 여부 확인
3. 글쓰기 오류 확인
4. 첨부로 업로드된 파일 저장
	-> 커넥션 생성
	-> 트랜잭션 시작
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
	-> 트랜잭션 COMMIT
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
	-> 트랜잭션 시작
9. 알림 메일 발송 이력을 DBMS에 저장
	-> 트랜잭션 COMMIT
	-> 커넥션 종료
10. 처리 완료



# 5.2 MySQL 엔진의 잠금

mysql에서 사용되는 잠금은 스토리지 엔진 레벨,
mysql 엔진 레벨로 나눌 수 있다.


## 5.2.1 글로벌 락

#글로벌_락 (Global Lock)은 FLUSH TABLES WITH READ LOCK 명령으로 흭득할 수 있다.
* mysql에서 제공하는 잠금 중 가장 범위가 큼
* 한 세션에서 글로벌 락 흭득 시, 다른 세션에서 select 제외한 대부분의 DDL, DML 실행 시 락이 해제될 때 까지 대기 상태로 남음
* 영향을 미치는 범위는 mysql 서버 전체


## 5.2.2 테이블 락

#테이블_락 (Table Lock)은 개별 테이블 단위로 설정되는 잠금이다. 명시적 or 묵시적으로 테이블 락을 흭득할 수 있으며,
명시적으로는 "LOCK TABLES table_name [ READ | WRITE ]"로 흭득
묵시적 테이블 락은 myisam이나 memory 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
mysql 서버가 데이터를 변경되는 테이블에 테이블 잠금을 설정하고,
데이터 변경 후, 즉시 잠금을 해제하는 형태로 사용

innodb에서는 레코드 기반 잠금을 제공하기에 단순 데이터 변경 쿼리로 묵시적 테이블 락 설정이 되지 않음.
DML 쿼리에선 무시, DDL의 경우에만 잠금


## 5.2.3 네임드 락

#네임드_락 (Named Lock)은 GET_LOCK() 함수를 사용하여 문자열에 대해 잠금 설정 가능
사용자가 지정한 문자열에 대해 흭득 및 반납하는 잠금

ex> 데이터베이스 서버 1대에 5대 웹 서버가 접속하여 서비스해야 하는 상황에서
5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건처럼
여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.



## 5.2.4 메타데이터 락

#메타데이터_락 (Metadata Lock)은 데이터베이스 객체(ex>테이블, 뷰)의 이름이나 구조를 변경하는 경우 흭득하는 잠금이다.

명시적 흭득 X
RENAME TABLE tab_a TO tab_b 처럼 이름 변경 시에 자동 흭득 O

RENAME TABLE 명령의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금 O



# 5.3 InnoDB 스토리지 엔진 잠금

innodb는 mysql에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 레코드 기반 잠금 방식을 탑재

myisam보다 훨씬 뛰어난 동시성 처리가 가능
하지만 이원화된 잠금 탓에 mysql 명령을 이용해 접근하긴 까다로움



## 5.3.1 InnoDB 스토리지 엔진의 잠금

* innodb는 레코드 기반 잠금을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리
	* 레코드 락이 페이지 락 or 테이블 락으로 레벨업되는 경우는 없다
* 레코드와 레코드 사이 간격을 잠그는 갭(GAP) 락이 존재


### 5.3.1.1 레코드 락
#레코드_락 : 레코드 자체만을 잠그는 걸 의미 / 다른 상용 DBMS와 동일한 역할
다만, innodb에서는 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
(인덱스가 없더라도 내부적으로 자동 생성된 클러스터 인덱스 사용)

레코드만 잠그느냐, 인덱스를 잠그느냐는 상당히 크고 작은 중요한 차이를 만든다.


### 5.3.1.2 갭 락
#갭_락 : 레코드 자체가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠금
레코드와 레코드 사이 새로운 레코드가 생성(INSERT) 되는 걸 제어


### 5.3.1.3 넥스트 키 락
#넥스트_키_락 (Next Key Look): 레코드 락 + 갭 락

* STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준 사용해야함
* innodb_locks_unsafe_for_binlog 시스템 변수가 비활성(0)화 되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸림
* 레플리카 서버에서 실행될 때 소스 서버에서 만든 결과와 동일한 결과를 만들도록 보장하는게 목적
* 단, 넥스트 키 락과 갭 락으로 인해 데드락 발생 or 다른 트랜잭션을 기다리게 만드는 일이 많으므로 되도록 바이너리 로그 포맷을 ROW 형태로 바꿔 넥스트 키 락, 갭 락을 줄이는 게 좋다



### 5.3.1.4 자동 증가 락
* 자동 증가하는 숫자 값을 위한 AUTO_INCREMENT 컬럼 속성을 위한 락
* INSERT/REPLACE 같은 새 레코드 저장 쿼리에서 필요, AUTO INCREMENT를 위해 짧은 시간동안 락이 걸렸다가 해제
* AUTO_INCREMENT가 락을 걸면 나머지는 락을 기다려야 함
	* 다만 앞서 말했듯, 아주 짧은 시간 락이 걸리므로 웬만한 서비스에서는 큰 문제는 없다.



## 5.3.2 인덱스와 잠금

레코드 락에서 보았듯이, innodb는 레코드를 잠그는 것이 아닌 인덱스를 잠그는 방식으로 처리된다.
즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.

![[Pasted image 20240531201128.png]]

update 문에서 인덱스를 이용할 수 있는 조건은 first_name='Georgi' 이다.
last_name 칼럼은 인덱스에 없기에
first_name = 'Georgi' 레코드 253건에 모두 잠긴다.

![[Pasted image 20240531201425.png]]

이 테이블에 인덱스가 하나도 없다면,
모든 테이블을 풀 스캔하며 update 작업을 한다.
이 과정에서 테이블에 있는 30여만건의 레코드를 모두 잠근다.



## 5.3.3 레코드 수준의 잠금 확인 및 해제

* 레코드 수준 잠금은 테이블 수준 잠금보다는 조금 복잡
* 잠금 대상이 테이블 자체일땐 쉽게 문제 원인이 발견 및 해결되지만, 레코드 수준은 레코드 각각 잠금이 걸리므로 자주 사용되지 않는 레코드는 오랜 시간 잠겨있어도 잘 발견되지 않음
* mysql 5.1 부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능하므로 쿼리 하나로 잠금과 잠금 대기 확인 가능



# 5.4 MySQL의 격리 수준

#트랜잭션_격리_수준 : 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경 or 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것

![[Pasted image 20240531173057.png]]

아래로 갈수록 트랜잭션간 격리 정도 UP, 동시 처리 성능 DOWN



## 5.4.1 READ UNCOMMITED

#READ_UNCOMMITED 에서는 각 트랜잭션의 변경 내용이
COMMIT, ROLLBACK 여부에 상관없이 다른 트랜잭션에 보인다.


![[Pasted image 20240531173411.png]]


한 가지 문제점이 있는데,
1. 사용자 A가 emp_no 500000이고 first_name이 "Lara"인 사원을 추가
2. 사용자 B가 변경된 내용 커밋 전에 emp_no=500000인 사원 검색
3. 하지만 B는 A가 insert한 사원 정보를 커밋되지 않은 상태에서도 조회 가능
4. 만약 사용자 A가 알 수 없는 오류로 롤백한다면? B는 Lara가 정상적인 데이터라 생각하고 처리함

이와 같은 현상을 #Dirty_Read 라 한다.
보다시피 RDBMS 표준에서 트랜잭션 격리 수준으로 인정하지 않을 수준으로 문제가 많다.
최소한 READ COMMITTED 이상 격리 수준을 사용할 것이 권장


## 5.4.2 READ COMMITTED

#READ_COMMITED  오라클 DBMS에서 기본으로 설정된 격리수준이다.
동시에 가장 많이 선택되는 격리수준이기도 하다.

어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.



![[Pasted image 20240531173749.png]]

1. 사용자 A는 emp_no=500000인 사원의 first_name을 "Lara"에서 "Toto"로 변경하였다.
	1. 이 때 새로운 값인 "Toto"는 employees 테이블에 즉시 기록
	2. 이전 값인 "Lara"는 언두 영역으로 백업
2. 사용자 A가 커밋 수행 전 사용자 B가 emp_no = 500000인 사원을 select 하면 조회된 값은 "Toto" 가 아닌 "Lara"가 조회된다. employees 테이블이 아닌, 언두 영역에 백업된 데이터를 가져온 것


다만, READ COMMITED에서도 "NON-REPEATABLE READ" ("REPEATABLE READ" 불가능) 부정합 문제가 있다.

![[Pasted image 20240531174208.png]]

1. 사용자 B가 BEGIN 명령으로 트랜잭션 시작 + first_name이 "Toto"인 사용자 검색 -> 일치하는 사용자 X
2. 사용자 A가 사원 번호가 500000인 사원의 이름을 "Toto"로 변경 후 커밋
3. 사용자 B가 똑같은 SELECT 쿼리로 다시 조회하면 이번에는 1건 조회

이는 별 다른 문제가 없어 보이지만,
사실 사용자 B가 하나의 트랜잭션 내에서 똑같은 select 쿼리를 실행했을 때
항상 같은 결과를 가져와야 한다는 "REPEATABLE READ" 정합성에 어긋난다.

일반적으론 크게 문제되지 않을 수 있지만
금전적인게 연관되어 있다면 문제가 있을 수 있음




## 5.4.3 REPEATABLE READ

#REPEATABLE_READ 는 mysql innodb 스토리지 엔진에서 기본으로 사용되는 격리수준
바이너리 로그를 가진 mysql 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 함

이 격리 수준에서는 앞선 NON-REPEATABLE READ 부정합이 발생하지 않는다.


MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해
동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장해준다.
READ COMMITTED도 MVCC로 커밋 전 데이터를 보여주나, 언두 영역 백업된 레코드의 여러 버전 중 몇 번째 이전 버전까지 찾아 들어가느냐의 차이다.

| MVCC : 롤백에 대비하여 변경 전 레코드를 undo 공간에 백업 후 실제 레코드 값 변경


innodb 트랜잭션은 모두 고유 트랜잭션 번호(순차적 증가)를 가지는데,
실행중인 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞서는 언두 영역 데이터는 삭제할 수 없다.
**즉, 자신 보다 번호가 낮은 트랜잭션이 커밋한 결과만 볼 수 있다


![[Pasted image 20240531175145.png]]


| employees 테이블은 번호가 6인 트랜잭션에 의해 insert됨
| 사용자 A가 emp_no가 500000인 사원의 이름을 변경하는 과정에서,
| 사용자 B가 emp_no가 500000인 사원을 select 할 때 어떤 과정이 처리될까?

1. 사용자 A의 트랜잭션 번호는 12, 사용자 B의 트랜잭션 번호는 10
2. 사용자 A는 사원 이름을 "Toto"라 변경하고 커밋
3. 사용자 B가 emp_no=500000인 사원을 A 트랜잭션 전후로 했지만 항상 'Lara"를 가져옴
	* 사용자가 begin  으로 트랜잭션 시작 후 10번 트랙잰션 번호를 부여받았는데, 10번 트랜잭션 안에서 실행되는 모든 select 쿼리는 10번보다 작은 트랜잭션 번호에서 변경한 것만 보이기 때문임


begin 명령으로 트랜잭션 실행 후 장시간 종료하지 않으면 언두 영역에 백업된 데이터가 무한정 커질 수도 있음
당연하게도 mysql 서버 처리 성능은 낮아질 수 있음



두 번째 부정합)

![[Pasted image 20240531184313.png]]


| A가 employees 테이블에 insert 도중 B가 select ... for update 쿼리로 employees 테이블 조회


앞서 내용대로라면 두 번 select 쿼리 결과는 동일해야 하나, 서로 다른 결과가 나온다.
이와 같이 다른 트랜잭션에서 수행한 변경 작업에 의해
레코드가 보였다 안보였다 하는 현상을 #Phantom_Read 혹은 #Phantom_Row 라 한다.

select ... for update 쿼리는 selct 하는 레코드 쓰기에 잠금을 걸어야 하는데,
언두 레코드에는 잠금을 걸 수 없다.

그래서 select .. for update, select ... lock in share mode로 조회되는 레코드는 언두 영역의 변경 전 데이터를 가져오는 게 아니라 현재 레코드의 값을 가져오게 되는 것이다



## 5.4.4 SERIALIZABLE

가장 단순한 격리 수준 + 가장 엄격한 격리 수준이다
당연하게도 동시 처리 성능도 다른 트랜잭션 경리 수준보다 떨어진다.

읽기 작업도 공유 잠금을 흭득해야 하고, 동시에 다른 트랜잭션은 해당 레코드를 변경할 수 없다.
읽거나 쓰고있는 레코드는 다른 트랜잭션에서 다 입구 컷 해버리는 것이다.