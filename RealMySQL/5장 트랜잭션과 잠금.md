```table-of-contents
```


5장은 MySQL의 동시성에 영향을 미치는 잠금(Lock), 트랜잭션, 격리 수준(Isolation Level)에 관한 이야기이다.
이야기 보따리를 풀어보자.



# 5.1 트랜잭션

트랜잭션은 존재 자체가 개발자에게 큰 혜택이다.


## 5.1.1 MySQL에서의 트랜잭션

트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합됬을 때에만 의미있는 게 아니다.
하나의 논리적인 작업 셋에 하나든, 두 개 이상이든 상관없이
작업 셋 자체가 100% 적용(commit 실행됬을 때) 되거나 아무것도 적용되지 않아야 (rollback) 함을 보장한다.


![[Pasted image 20240529003538.png]]

비교를 위해 트랜잭션을 지원하지 않는 myisam과 트랜잭션을 지원하는 innodb에 각각 레코드를 저장해보자.


![[Pasted image 20240529003653.png]]

auto-commit을 on 한 뒤, 위 문장을 각 스토리지 엔진에서 실행해보자.


![[Pasted image 20240529003721.png]]
![[Pasted image 20240529003726.png]]


두 insert 모두 프라이머리 키 중복으로 쿼리가 실패했다고 뜬다.
하지만 myisam에서 조회를 해보면 오류가 발생했음에도 '1', '2'는 insert 된 상태로 남아있다.
즉, insert 문장이 1, 2를 저장하고 3을 저장하면서 오류가 발생했지만,
**이미 insert 된 1, 2는 그대로 두고 쿼리를 종료했기 때문이다!!!!**

즉, 트랜잭션은 골치 아픈 기능 정도로 생각할 수 있지만,
없으면 훨씬 골치 아픈 상황이 나타날 수도 있는 것이다.




## 5.1.2 주의사항

* 트랜잭션 또한 DBMS 커넥션과 비슷하게 최소의 코드에만 적용
	* = 트랜잭션의 범위를 최소화하라는 의미


1. 처리시작
	 -> 데이터베이스 커넥션 생성
	 -> 트랜잭션 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
9. 알림 메일 발송 이력을 DBMS에 저장
    <- 트랜잭션 종료 (commit)
    <- 데이터베이스 커넥션 반납
10. 처리 완료

* 트랜잭션이 필요한 C,U,D는 5번부터 시작이기에 2,3,4를 트랜잭션에 포함시킬 필요는 없음
* 8번은 메일전송/FTP 등 네트워크 통신 작업이기에 DBMS 트랜잭션에서 제거하는게 좋음
	* 메일 서버와 통신할 수 없는 상황이 발생하면 웹 서버와 DBMS 서버까지 위험해질 수 있기 때문


**보완하여 재설계한 절차

1. 처리 시작
2. 로그인 여부 확인
3. 글쓰기 오류 확인
4. 첨부로 업로드된 파일 저장
	-> 커넥션 생성
	-> 트랜잭션 시작
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
	-> 트랜잭션 COMMIT
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
	-> 트랜잭션 시작
9. 알림 메일 발송 이력을 DBMS에 저장
	-> 트랜잭션 COMMIT
	-> 커넥션 종료
10. 처리 완료



# 5.2 MySQL 엔진의 잠금

mysql에서 사용되는 잠금은 스토리지 엔진 레벨,
mysql 엔진 레벨로 나눌 수 있다.


## 5.2.1 글로벌 락

#글로벌_락 (Global Lock)은 FLUSH TABLES WITH READ LOCK 명령으로 흭득할 수 있다.
* mysql에서 제공하는 잠금 중 가장 범위가 큼
* 한 세션에서 글로벌 락 흭득 시, 다른 세션에서 select 제외한 대부분의 DDL, DML 실행 시 락이 해제될 때 까지 대기 상태로 남음
* 영향을 미치는 범위는 mysql 서버 전체


## 5.2.2 테이블 락

#테이블_락 (Table Lock)은 개별 테이블 단위로 설정되는 잠금이다. 명시적 or 묵시적으로 테이블 락을 흭득할 수 있으며,
명시적으로는 "LOCK TABLES table_name [ READ | WRITE ]"로 흭득
묵시적 테이블 락은 myisam이나 memory 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
mysql 서버가 데이터를 변경되는 테이블에 테이블 잠금을 설정하고,
데이터 변경 후, 즉시 잠금을 해제하는 형태로 사용

innodb에서는 레코드 기반 잠금을 제공하기에 단순 데이터 변경 쿼리로 묵시적 테이블 락 설정이 되지 않음.
DML 쿼리에선 무시, DDL의 경우에만 잠금


## 5.2.3 네임드 락

#네임드_락 (Named Lock)은 GET_LOCK() 함수를 사용하여 문자열에 대해 잠금 설정 가능
사용자가 지정한 문자열에 대해 흭득 및 반납하는 잠금

ex> 데이터베이스 서버 1대에 5대 웹 서버가 접속하여 서비스해야 하는 상황에서
5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건처럼
여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.



## 5.2.4 메타데이터 락

#메타데이터_락 (Metadata Lock)은 데이터베이스 객체(ex>테이블, 뷰)의 이름이나 구조를 변경하는 경우 흭득하는 잠금이다.

명시적 흭득 X
RENAME TABLE tab_a TO tab_b 처럼 이름 변경 시에 자동 흭득 O

RENAME TABLE 명령의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금 O



# 5.3 InnoDB 스토리지 엔진 잠금

innodb는 mysql에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 레코드 기반 잠금 방식을 탑재

myisam보다 훨씬 뛰어난 동시성 처리가 가능
하지만 이원화된 잠금 탓에 mysql 명령을 이용해 접근하긴 까다로움



## 5.3.1 InnoDB 스토리지 엔진의 잠금

* innodb는 레코드 기반 잠금을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리
	* 레코드 락이 페이지 락 or 테이블 락으로 레벨업되는 경우는 없다
* 레코드와 레코드 사이 간격을 잠그는 갭(GAP) 락이 존재


### 5.3.1.1 레코드 락
#레코드_락 : 레코드 자체만을 잠그는 걸 의미 / 다른 상용 DBMS와 동일한 역할
다만, innodb에서는 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
(인덱스가 없더라도 내부적으로 자동 생성된 클러스터 인덱스 사용)

레코드만 잠그느냐, 인덱스를 잠그느냐는 상당히 크고 작은 중요한 차이를 만든다.


### 5.3.1.2 갭 락
#갭_락 : 레코드 자체가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠금
레코드와 레코드 사이 새로운 레코드가 생성(INSERT) 되는 걸 제어


### 5.3.1.3 넥스트 키 락
#넥스트_키_락 (Next Key Look): 레코드 락 + 갭 락

* STATEMENT 포맷의 바이너리 로크를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준 사용해야함
* innodb_locks_unsafe_for_binlog 시스템 변수가 비활성(0)화 되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸림
* 레플리카 서버에서 실행될 때 소스 서베에서 만든 결과와 동일한 결과를 만들도록 보장하는게 목적
* 단, 넥스트 키 락과 갭 락으로 인해 데드락 발생 or 다른 트랜잭션을 기다리게 만드는 일이 많으므로 되도록 바이너리 로그 포맷을 ROW 형태로 바꿔 넥스트 키 락, 갭 락을 줄이는 게 좋다



### 5.3.1.4 자동 증가 락
* 자동 증가하는 숫자 값을 위한 AUTO_INCREMENT 컬럼 속성을 위한 락
* INSERT/REPLACE같은 새 레코드 저장 쿼리에서 필요, AOTO INCREMENT를 위해 짧은 시간동안 락이 걸렸다가 해제
* AUTO_INCREMENT가 락을 걸면 나머지는 락을 기다려야 함
	* 다만 앞서 말했듯, 아주 짧은 시간 락이 걸리므로 큰 문제는 없다.



## 5.3.3 레코드 수준의 잠금 확인 및 해제

* 레코드 수준 잠금은 테이블 수준 잠금보다는 조금 복잡
* 잠금 대상이 테이블 자체일땐 쉽게 문저 원인이 발견 및 해결되지만, 레코드 수준은 레코드 각각 잠금이 걸리므로 자주 사용되지 않는 레코드는 오랜 시간 잠겨있어도 잘 발견되지 않음
* mysql 5.1 부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능하므로 쿼리 하나로 잠금과 잠금 대기 확인 가능



# 5.4 MySQL의 격리 수준

