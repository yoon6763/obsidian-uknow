```table-of-contents
```



# 4.1 MySQL 엔진 아키텍처

MySQL 서버는 다른 DBMS에 비해 독특한 편
사용자 입장에서는 별 차이 못 느낄 수 있으나
독특한 구조로 다른 DBMS와 다르게 엄청난 혜택을 누릴 수가 있음!
반면에 다른 DBMS에서는 문제되지 않을 게 문제되기도 함(...)

## 4.1.1  MySQL의 전체 구조

![[Pasted image 20240515022551.png]]

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분!



### 4.1.1.1 MySQL 엔진
(커넥션 핸들러) 클라이언트로부터 접속 및 쿼리 요청
(옵티마이저) SQL 파서, 전처리기, 쿼리 최적화


4.1.1.2 스토리지 엔진






### 4.1.2.2 백그라운드 스레드
MyISAM은 별로 해당사항이 없지만 InnoDB는 여러 작업이 백그라운드로 처리
* 인서트 버퍼(insert buffer)를 병합하는 스레드
* 로그를 디스크로 병합하는 스레드
* InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
* 데이터를 버퍼로 읽어 오는 스레드
* 잠금이나 데드락을 모니터링 하는 스레드

데이터 쓰기/읽기 스레드 개수 2개 이상 지정 가능
innodb_write_io_threads, innodb_read_io_thread으로 지정

데이터 쓰기는 지연될 수 있음,
데이터 읽기는 지연될 수 없음. (SELECT 실행하면 10분 뒤 결과 알려드림 -> 이런 건 없다)

쓰기 작업은 버퍼링해서 일괄처리, InnoDB 포함.
그러니 MyISAM은 사용자 스레드가 쓰기까지 함께 처리


## 4.1.3 메모리 할당 및 사용 구조

![[Pasted image 20240515023822.png]]

mysql이 사용하는 메모리 공간 -> 글로벌 메모리 영역 vs 로컬 메모리 영역

글로벌 메모리 : mysql 서버 시작 시 운영체제로부터 할당


### 4.1.3.1 글로벌 메모리 영역
클라이언트 스레드 수와 무관하게 1개 메모리 공간만 할당 (필요에 따라 2개 이상도 가능, 단 클라이언트 스레드 수와는 무관)

모든 스레드에 의해 공유

* 테이블 캐시
* InnoDB 버퍼 풀
* InnoDB 어댑티브 해시 인덱스
* InnoDB 리두 로그 버퍼



### 4.1.3.2 로컬 메모리 영역
= 세션 메모리 영역 = 클라이언트 메모리 영역
클라이언트 커넥션으로부터 요청을 처리하기 위해 스레드 하나씩 담당

각 클라이언트 스레드별로 독립 할당 / 절대 공유되지 않음

* 정렬 버퍼(Sort Buffer)
* 조인 버퍼
* 바이너리 로그 캐시
* 네트워크 버퍼



## 4.1.4 플러그인 스토리지 모델

![[Pasted image 20240515024623.png]]


mysql의 독특한 구조, 플러그인 모델

여러 스토리지 엔진을 플러그인 형태로 추가해서 사용함


![[Pasted image 20240515024852.png]]

거의 대부분이 MySQL 엔진 처리 영역에서 처리
마지막 데이터 읽기/쓰기만 스토리지 엔진에 의해 처리

MySQL 서버에서 mysql 엔진은 사람 역할을, 각 스토리지 엔진은 자동차 역할을,
mysql 엔진이 스토리지 엔진을 조정하기 위해 핸들러라는 걸 사용함

핸들러가 뭔지 몰라도 됨. mysql 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나
저장하도록 명령하려면 핸들러를 거처야 한다는 것만 기억하도록.



## 4.1.5 컴포넌트

MySQL 8.0 부터는 기존의 플러그인 아키텍처를 대체하기 위한 컴포넌트 아키텍처가 도입


플러그인 단점
* 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인 끼리는 불가
* 플러그인은 MysQL 서버의 변수나 함수를 직접 호출, 안전하지 않음, 캡슐화 X
* 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움

비밀번호 검증 기능 -> 기존에는 플러그인 형태로 제공됨
반면 8.0 부터는 컴포넌트로 개선


## 4.1.6 쿼리 실행 구조

![[Pasted image 20240515030547.png]]

### 4.1.6.1 쿼리 파서
사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리
이후 트리 형태의 구조로 변환
기본 문법 오류는 이 단계에서 발견 및 에러 메시지 전달


### 4.1.6.2 전처리기
파서 과정에서 만들어진 파서 트리가 쿼리 문장에 구조적 문제가 있는지 확인
각 토큰을 테이블 이름, 칼럼 이름, 내장 함수와 개체를 매핑, 존재 여부와 접근 권한 확인


### 4.1.6.3 옵티마이저
쿼리 문장을 저렴한 비용으로 가장 빨리 처리할지 결정, DBMS의 두뇌


### 4.1.6.4 실행 엔진
옵티마이저 -> 두뇌
실행엔진 / 핸들러 -> 손, 발

옵티마이저가 Group By를 처리하기 위해 임시 테이블을 사용한다고 결정했다하자
1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자 or 다른 모듈로 넘김

즉 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청 + 받은 결과를 또 다른 핸들러 요청의 입력으로 연결


### 4.1.6.5 핸들러 (스토리지 엔진)
핸들러는 mysql 서버의 가장 밑단에서 mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장 or 읽어옴
myisam 테이블을 조작할 경우 핸들러가 myisam 스토리지 엔진이 됨
innodb 테이블을 조작할 경우 핸들러가 innodb 스토리지 엔진이 됨


## 4.1.7 복제
복제는 매우 중요한 역할을 담당한다. 별도의 장에서 살펴본댄다. 넘어간다.


## 4.1.8 쿼리 캐시
쿼리 캐시(Query Cache)는 빠른 응답을 필요로 하는 웹 기반 응용 프로그램에서 중요 역할

SQL 실행 결과를 메모리에 캐시, 동일 SQL이 실행되면 테이블을 읽지 않고 결과 반환
듣기만 했는데도 진짜 ㄹㅇ 빨라보이지만

테이블 데이터가 변경되면 이와 연관된 데이터 중 캐시에 저장된건 모두 삭제됨
심각한 동시 처리 성능을 저하 유발 + 많은 버그 원인 -> 결국 삭제 엔딩 8.0



## 4.1.9 스레드 풀(Thread Pool)
서버 엔터프라이즈 에디션 -> 스레드 폴 O
커뮤니티 에디션 -> 스레드 폴 X

스레드 폴은 내부적으로 사용자 요청 처리 스레드 개수를 줄여서,
동시 처리 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 하여 서버 자원 소모를 줄이는 것이 목적

??? : 스레드 풀만 설치하면 성능 두 배쯤 올라가는거 아냐? -> 예끼 이놈!
실제 스레드 풀이 눈에 띄는 성능 향상을 보여준 건 드물었다.

동시 실행 중인 스레드들을 CPU가 최대한 잘 처리하낼 수 있는 수준으로 줄여 빨리 처리하게 하는 기능이기에,
CPU 시간을 제대로 확보하지 못할 경우 오히려 쿼리가 느려지기도 함


CPU의 프로세서 친화도를 높이고 운영체제 입장에서 불필요한 컨텍스트 스위칭을 줄여 오버헤드를 낮출 수 있다


기본적으로 CPU 코어 수 많큼 스레드 그룹을 만드는데, thread_pool_size 변수로 제어
스레드 그룹의 모든 스레드가 일을 처리하고 있다면
스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지,,,
아님 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 판단해야 해

thread_stall_limit 밀리초 만큼 작업 스레드가 지금 처리 중인 작업을 끝내지 못하면 새 스레드를 추가할꺼야

즉, 모든 스레드가 모두 일하는 중일 때 새 요청이 들어와도 thread_stall_limit 시간 만큼 기다려야 새 요청을 처리할 수 있다는 이야기. 따라서 응답 시간에 아주 예민하다면 적절하게 낮추자. 하지만 0에 가까운 값에 설정하는 건 권장하지 않아. 0에 가깝다면 스레드 풀을 사용하지 않는 편이 나을 것이기에.



### 4.1.10 트랜잭션 지원 메타 데이터
테이블의 구조 정보와 스터오드 프로그램 등의 정보를 데이터 딕셔너리 or 메타데이터라 함
5.7 버전까지 FRM 파일에 저장했으나 파일 기반 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않음!
테이블 생성 또는 변경 도중 mysql 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남아 있는 문제가 생김 (= DB or 테이블이 깨졌다)

때문에 관련 정보를 모두 InnoDB 테이블에 저장하도록 개선
모두 트랜잭션 기반이기에 mysql 서버가 중간에 비정상 정료 되더라도 스키마 변경이 완전 성공 or 완전 실패로 정리

ACID? 원자성과 관련 있는듯



# 4.2 InnoDB 스토리지 엔진 아키텍처

![[Pasted image 20240515160430.png]]

mysql 스토리지 엔진 중 가장 많이 사용되는 건 InnoDB 이다
그러타! mysql 스토리지 엔준 중 거의 유일하게 레코드 기반 잠금을 지원한다!
그러타! 높은 동시성 처리가 가능하다! 성능이 뛰어나다!



## 4.2.1 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장
-> 프라이머리 키 값의 순서대로 디스크에 저장
-> 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용

pk를 기준으로 클러스터링 되니까 당연히 pk 이용 레인지 스캔은 빠르겠죵?
따라서 pk는 다른 보조 인덱스에 비해 비중이 높게 설정

InnoDB와는 달리 MyISAM에서는 클러스터링 키 지원 X
-> 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다
그냥 유니크 제약을 가진 세컨더리 키일 뿐



## 4.2.2 외래 키 지원
MyISAM이나 MEMORY 테이블에서는 외래키는 안된다. InnoDB에서만 가능하다.

외래 키는 DB 서버 운용 불편함 때문에 서비스용 데이터 베이스에서는 사용하지 않는 경우도 있다.
InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요함
변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크해야 하는 작업이 필요
-> 잠금이 여러 테이블로 전파, 데드락 발생 가능성 UP

긴급하게 조치를 해야 하는데 외래키가 얽힌 경우 머리 터질 수도 있음
foregin_key_chekcs를 off로 하면 외래키 관계에 대한 작업을 일시적 비활성화 가능



## 4.2.3 MVCC(Multi Version Concurrency Control)
레코드 레벨 트랜잭션 -> 일반적으로 DBMS가 지원
MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있음

![[Pasted image 20240515162559.png]]

![[Pasted image 20240515162603.png]]


![[Pasted image 20240515162650.png]]
![[Pasted image 20240515162654.png]]

UPDATE 문장 실행 -> 커밋 실행 여부와 상관 없이 버퍼 풀은 업데이트

그런데!!! 아직 commit or rollback 되지 않은 상황에서 다른 사용자가 조회하면 어디에 있는 걸 조회하나?

정답은 transaction_isolation에 설정된 격리 수준(Isolation level)에 따라 다르다! (두둥 - 탁!)

READ_UNCOMMITED -> InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어 반환
READ_COMMIT or 그 이상(REPLATABLE_READ, SERIALIZABLE) -> 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경 이전 내용을 보관하고 있는 언두 영역 데이터 반환 ㄴ ㅇㅁㅇ ㄱ
DBMS에서는 MVCC 라고 표현


## 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
INSERT와 연결되지 않는 순수 읽기(SELECT) 작업은 다른 트랜잭션 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다!

특정 사용자가 레코드 변경 ~ 커밋 수행함과 관련 없이 다른 사용자의 SELECT 작업을 방해하지 않음
이를 '잠금 없는 일관된 읽기' 라고 한다


## 4.2.5 자동 데드락 감지
InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해
잠금 목록을 그래프(wait-for-list) 형태로 관리

데드락 감지 스레드를 가지고 있어서 얘가 주기적으로 잠금 대기 그래프를 검사해
교착 상태에 빠진 트랜잭션 검사하고 그 중 하나 강제 종료함

어느 걸 먼저 강제 종료 할 건지 판단 기준은 트랜잭션 언두 로그 양,
언두 로그 레코드를 적게 가질수록 일반적으로 롤백 대상
(언두 레코드가 적다는 건 언두 처리할 내용이 적다는 거고 강제 롤백 새 서버 부하가 적다는 것이기 때문)

일반적인 서비스에서는 데드락 감지 스레드가 트랜잭션 잠금 목록 검사 후 데드락 찾아내는 작업은 그리 부담되지는 않음
하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금 개수가 많아지면 데드락 감지 스레드가 느려짐

데드락 감지 스레드는 잠금 목록을 검사해야 하기 때문에
잠금 목록 저장 리스트에 새로운 잠금을 걸고 데드락 스레드를 찾음

데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기 -> 서비스에 악영향
동시 처리 스레드가 매우 많아지면 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있음


## 4.2.6 자동화된 장애 복구

InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 매커니즘 탑재! 와!

mysql 서버 시작될 때 완료되지 못한 트랜잭션 or 일부만 기록된 페이지 -> 복구 작업 자동 실행

데이터 파일 손상 or mysql 서버가 시작되지 못하는 경우는 거의 없으나
디스크나 서버 하드웨어 이슈로 InnoDB가 자동 복구 못할수도 있다,,,
일 단 한 번 문제가 생기면 복구 쉽지 않아서 복잡하다고 보면 된다.
자동복구 못하고 그냥 종료되어 버림

이럴땐 innodb_force_recovery 변수로 mysql 서버 시작해야함

* InnoDB의 로그 파일이 손상됬다면 6으로 설정하고 mysql 서버 기동
* InnoDB 테이블의 데이터 파일이 손상됬다면 1로 설정하고 mysql 서버 기동
* 어떤게 문젠지 모른다면 1~6까지 변경하면서 서버 재시작
	* 참고로 숫자가 커질수록 심각한거다... 데이터 손실 가능성 UP, 복구 가능성 DOWN


innodb_force_recovery
* 1 (SRV_FORCE_IGNORE_CORRUPT)
	* InnoDB 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분 발견해도 무시 + 서버 시작
* 2 (SRV_FORCE_NO_BACKGROUND)
	* InnoDB 쿼리 처리를 위해 여러 종류 백그라운드 스레드 동시 사용, 메인 스레드 시작하지 않고 mysql 서버 실행
* 3 (SRTV_FORCE_NO_TRX_UNDO)
	* InnoDB 트랜잭션이 실행되면 롤백에 대비해 변경 전의 데이터를 언두 영역에 기록
	* mysql 서버는 다시 시작하면서 언두 영역 데이터를 먼저 데이터 파일에 적용 + 그 다음 리두 로그 내용을 덮어써서 장애 시점 데이터 상태를 만들어냄
	* 정상 mysql 서버에서는 최종적으로 커밋되지 않은 트랜잭션은 롤백하지만 3단계에서는 롤백 x 그대로 납둠 o
* 4 (SRV_FORCE_NO_ UNDO_LOG_SCAN)
	* INSERT, UPDATE, DELETE 등 데이터 변경으로 인한 인덱스 변경 작업을 상황에 따라 즉시 처리할 수도 있고 인서트 버퍼에 저장해두고 나중에 처리할 수도 있음
	* 4단계에서는 인서트 버퍼 내용을 무시 + 강제로 mysql 시작
* 5 (SRV_FORCE_UNDO_LOG_SCAN)
	* mysql 서버가 장애 or 정상적 종료 시점 진행 중인 트랜잭션이 있다면 mysql은 그냥 단순히 커넥션을 끊고 별도 정리 없이 그냥 종료함. 재실행 시 언두 레코드를 이용해 데이터 페이지를 복구 및 리두 로그를 적용하여 장애 or 종료 시점 재현. innodb는 마지막으로 커밋되지 않은 트랜잭션은 모두 롤백처리. 그런데 innodb 언두 로그를 사용할 수 없다면 mysql 실행 불가
	* 이 때 5단계로 설정하면 스토리지 엔진을 모두 무시하고 mysql 엔진 실행 가능
	* 종료 시점 커밋되지 않았던 작업도 모두 커밋된 것 처럼 처리되므로 잘못된 데이터가 db에 남는 것으로 볼 수 있음
* 6 (SRV_FORCE_NO_LOG_REDO)
	* innodb 스토리지 엔진의 리두 로그가 손상되면 mysql 서버가 실행되지 못함
	* 6단계에서는 리두 로그를 모두 무시한 채 mysql 서버 실행
	* 커밋됬다 하더라도 리두 로그에만 기록되고 데이터 파일에 기록되지 않았다면 모두 무시



## 4.2.7 InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
쓰기 작업 지연을 통한 일괄 작업으로 처리할 수 있게 해주는 버퍼역할도 같이 함

데이터 변경 쿼리(UPDATE/INSERT/DELETE) 등은 데이터베이스 이곳저곳을 변경
-> 랜덤한 디스크 작업 발생

하지만 버퍼풀이 출동한다면?
-> 변경된 데이터를 모아 처리하기 때문에 랜덤한 디스크 작업 횟수를 줄일 수 있다



### 4.2.7.1 버퍼 풀의 크기 설정

일반적으로 전체 물리 메모리의 80% 정도를 InnoDB 버퍼풀로 설정하라 -> X
그렇게 단순하게 설정하면 안됨.

고려요소 : **운영체제, 각 클라이언트 스레드가 사용할 메모리**

MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없으나,
아주 독특한 경우 레코드 버퍼가 상당한 메모리를 잡아먹기도 함.

#레코드_버퍼  : 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 사용하는 버퍼.

커넥션이 많고 사용하는 테이블이 많다 -> 레코더 버퍼 용도로 사용되는 메모리 공간이 많이 필요해질 수도 있음
MySQL 서버가 사용하는 레코드 버퍼 공간 -> 별도로 설정 할 수 없다.
전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블의 개수에 따라 결정됨

mysql 5.7 부터는 InnoDB의 버퍼 풀 크기를 동적으로 조절 할 수 있게됨
InnoDB 버퍼 풀 크기를 적절히 낮은 값으로 설정해서 조금씩 올리는게 최적!


> 운영체제의 메모리가 8GB 미만이라면 50% 정도만 InnoDB 버퍼 풀로 설정하고,
> 그 이상이라면 50%에서 시작해 조금씩 올려가며 최적점을 찾자.


InnoDB 버퍼 풀은 innodb_buffer_pool_size로 설정하며 동적으로 지정가능
다만, 크리티컬 변경이므로 mysql 서버가 한가할 때 하자.
버퍼 풀을 크게 하는 건 별 문제가 없으나, 줄이면 서비스 영향이 매우 크게 간다.

InnoDB 버퍼 풀은 세마포어로 내부 잠금 경합을 유발했다.
경합을 줄이기 위해 버퍼 풀을 여러 개로 쪼개어 관리할 수 있게 개선하였으며,
innodb_buffer_pool_instance 시스템 변수로 여러 개로 분리해 관리 가능.

각 버퍼 풀을 버퍼 풀 인스턴스라고 표현.
1GB 미만이라면 버퍼 풀 인스턴스는 1개로 초기화, 이상이라면 기본적으로 8개로 초기화



### 4.2.7.2 버퍼 풀의 구조

InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기 조각으로 쪼개어 필요 시 마다 페이지를 읽는다.

크기 조각을 관리하기 위해
* LRU (Least Recently Used) 리스트 : 아래 그림 참조
* 플러시 (Flush) 리스트
* 프리 (Free) 리스트 : InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 빈 페이지 목록
3개 자료 구조를 관리.



![[Pasted image 20240520181937.png]]


LRU 리스트는 엄밀하게는 LRU와 MRU(Most Recently Used)가 결합된 형태라 할 수 있음
Old 서브리스트 영역은 LRU, New 서브리스트 영역은 MRU로 보면 된다

리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오래 기억하고 있음으로써 디스크 읽기를 최소하는 것이다.


#InnoDB_스토리지_엔진에서_데이터를_찾는_과정 

필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
A. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
B. 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색
C. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 LRU 헤더 부분에 추가
디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가

버퍼 풀에 상주한 데이터는 최근 접근에 따라 나이(Age) 부과
상주할 동안 나이를 먹고(Aging) 수명을 넘기면 자연사함
쿼리에 의해 사용되면 0살로 다시 회춘함



#플러시리스트  : 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지) 변경 시점 기준 목록 관리

디스크에서 읽은 뒤 변경이 없다 -> 플러시 리스트에 관리 X
한 번 데이터 변경이 가해짐 -> 플래시 리스트에서 관리

변경되면 리두 로그에 기록 후 버퍼 풀의 데이터 페이지에도 변경 내용 반영





### 4.2.7.3 버퍼 풀과 리두 로그

InnoDB 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정할수록 쿼리의 성능이 빨라진다
(단, 이미 디스크의 모든 데이터 파일이 버퍼 풀에 적재될 정도의 공간이라면 늘린다고 더 빨라지진 않는다)


![[Pasted image 20240520202235.png]]


InnoDB 버퍼 풀은 데이터베이스 서버 성능 향상 용도
* 데이터 캐시
* 쓰기 버퍼링
참고로 버퍼 풀의 메모리 공간만 늘리는던 데이터 캐시 기능만 향상키는 것.


InnoDB의 버퍼 풀
* 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지와
* 변경된 데이터를 가진 더티 페이지가 있다.
	* 변경됐으므로 언젠간 디스크로 기록되야 한다
	* 하지만 버퍼 풀에 무한정 머무를 순 없다

리두 로그는 1개 이상의 고정 파일을 연결하여 순환 고리처럼 사용하며
데이터 변경이 계속 발생하면 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다.
따라서 InnoDB는 전체 리두 로그 파일에서 재사용 가능, 당장 재사용 불가능한 공간을 구분해 관리
여기서 재사용 불가능한 공간을 활성 리두 로그라고 한다.


LSN(Log Sequence Number) : 리두 로그 파일 공간은 계속 재사용되나, 기록될 때 마다 포지션은 증가. 이를 LSN이라 함


리두 로그 - 버퍼 풀 더티 페이지 동기화
- 주기적으로 체크포인트 이벤트 발생
- 가장 최근 체크포인트 지점이 LSN 활성 리두 로그 공간의 시작점
- 가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN 차이를 체크포인트 에이지라 함
	- 항상 활성 리두 공간의 크기를 의미



### 4.2.7.4 버퍼 풀 플러시(Buffer Pool Flush)

InnoDb는 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지를 동기화 하기 위해 2개 플러기 기능을 백그라운드에서 실행한다
* 플러시 리스트 플러시
* LRU 리스트 플러시


#### 4.2.7.4.1 플러시 리스트 플러시

리두 로그 공간을 재활용하려면? 주기적으로 리두 로드 엔트리 공간을 비워야겠죠?
플러시 리스트 플러시 함수를 호출하여 변경된 페에지를 동기화할 수 있습니다!

InnoDB는 다음과 같은 시스템 변수를 제공함
* innodb_page_cleaners
	* 클리너 스레드의 개수 조정
	* 클리너 스레드 : 더티 페이지를 디스크로 동기화 하는 스레드
	* 설정값이 버퍼 풀 인스턴스 보다 많다면 innodb_buffer_poll_instances로 자동 변경
* innodb_max_dirty_pages_pct
	* 더티 페이지 비율 조정
	* 더티 페이지를 많이 가지고 있을수록 디스크 쓰기 작업을 버퍼링 -> 여러 번 디스크 쓰기를 한 번으로
* innodb_max_dirty_pages_pct_lwm
	* 더티 페이지가 많으면 디스크 쓰기 폭발 가능성 있음
	* 일정 수준의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록하게 하는 변수
* innodb_io_capacity
	* 데이터베이스 서버에서 어느 정도의 디스크 읽고 쓰기가 가능한지 결정
	* 여기서 디스크 읽고 쓰기는 백그라운드 스레드가 수행하는 디스크 작업을 의미 (대부분 더티 페이지 쓰기)
* innodb_io_capacity_max
	* 디스크가 최대 성능을 발휘할 때 어느 정도의 디스크 읽고 쓰기가 가능한지 설정
* innodb_flush_neighbors
	* 더티 페이지를 디스크에 기록 시 근접한 페이지 중 더티 페이지가 있다면 함께 묶어 디스크로 기록
	* 한 번이라도 디스크 읽기 쓰기를 줄이기 위한 노력의 결과임
	* SSD에서는 기본값인 비활성 모드로 유지 권장
* innodb_adaptive_flushing
	* 어댑티브 플러시 사용 유무 (기본값 : 사용)
	* 활성화되면 InnoDB는 단순히 버퍼 풀의 더티 페이지 비율 / 위 환경변수값에 의존하지 않고 새로운 알고리즘 사용
	* 더티 페이지를 어느정도 기록해야 할까요?
		-> 리두 로그가 어느 정도 속도로 증가하는지를 분석하는 것과 같다
		리두 로그의 증가 속도 분석하여 -> 적절 수준 더티 페이지가 버퍼 풀에 유지할 수 있게 함
* innodb_adaptive_flushing_lwm
	* 기본값 : 10%, 10% 이상일 때 어댑티브 플러시 알고리즘 작동



#### 4.2.7.4.2 LRU 리스트 플러시
LRU 리스트 플러시 함수 : LRU 리스트에서 사용 빈도가 낮은 데이터 페이지를 제거하여 공간마련

범위 : LRU 리스트 끝부분부터 시작 ~ 최대 innodb_lru_scan_depth 개수만큼 스캔

스캔하면더 더티 페이지는 디스크에 동기화



### 4.2.7.5 버퍼 풀 상태 백업 및 복구

워밍 업 : 디스크의 데이터가 버퍼 풀에 적재되 있는 상태. 잘 워밍업 되어있으면 그렇지 않은 경우보다 몇십 배 쿼리 처리 속도를 보임

5.6 부터 버퍼 풀 덤프 및 적재 기능이 도입되어
재시작 할 경우 innodb_buffer_pool_dump_now로 InnoDB 버퍼 풀의 상태 백업 가능

ib_buffer_pool 이라는 이름으로 백업
* 메타 정보만 저장하므로 백업은 매우 빠름
* 읽을땐 오래걸림. 백업 내용에서 각 테이블의 데이터 페이지를 다시 디스크에서 읽기 때문
* 너무 오래걸려서 멈추려면 innodb_buffer_pool_load_abort 사용



### 4.2.7.6 버퍼 풀의 적재 내용 확인

information_schema 데이터베이스의 innodb_buffer_page 테이블로 InnoDB 버퍼 풀의 메모리에 어떤 테이블의 페이지들이 적재되어있는지 확인
-> 테이블 조회가 상당히 큰 부하를 일으켜 서비스 쿼리가 많이 느려짐

8.0 버전부터 information_schema 데이터베이스에 추가된 innodb_cached_indexs 테이블로 데이터 페이지가 얼마나 innodb 버퍼 풀에 적재되 있는지 확인 가능



## 4.2.8 Double Write Buffer

파셜 페이지 / 톤 페이지 : 더티 페이지를 디스크 파일로 플러시 할 때 일부만 기록되는 현상

Double-write : 파셜 페이지 / 톤 페이지를 피하기 위해 사용되는 기법

![[Pasted image 20240521101655.png]]


1. InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에 A~E 데이터를 묶어 한 번의 디스크 쓰기로 테이블 스테이스의 DoubleWrite 버퍼에 기록
2. 각 더티 페에지를 파일의 적당한 위치에 하나씩 랜덤 쓰기
3. DoubleWrite 버퍼 공간에 기록된 변경 내용은 더 이상 쓸모가 없어짐

DoubleWrite 기능 사용 여부는 innodb_doublewrite로 제어




## 4.2.9 언두 로그

InnoDB는 트랜잭션과 격리 수준 보장을 위해 INSERT/UPDATE/DELETE 전 데이터를 백업함
백업된 데이터를 언두 로그(Undo Log) 라고 함

#언두_로그 InnoDB는 트랜잭션과 격리 수준 보장을 위해 INSERT/UPDATE/DELETE 전 데이터를 백업함
백업된 데이터를 언두 로그(Undo Log) 라고 함
* 트랜잭션 보장
	* 트랜잭션 롤백 시 변경된 데이터를 복구해야함
* 격리 수준 보장
	* 특정 커넥션에서 데이터를 변경하는 도중 다른 커넥션에서 데이털르 조회해도, 격리 수준에 맞게 변경중인 레코드를 읽지 않고도 언두 로그에 백업된 데이터를 읽어 반환하기도 함


### 4.2.9.1 언두 로그 레코드 모니터링

> mysql> UPDATE member SET name = '홍길동' WHERE member_id=1;

위 문장이 실행되면 트랜잭션 커밋 전에도 데이터파일(인덱스버퍼)는 '홍길동'으로 변경됨
커밋하게 된다면? -> 그대로 유지
롤백하면? -> 언두 영역 백업된 데이터를 복구

언두 로그 데이터의 용도
1. 위에서 언급한 트랜잭션 롤백 대비용
2. 트랜잭션 격리 수준을 유지 + 높은 동시성


> 자, DLEETE로 100GB 크기의 테이블을 삭제한다고 하자
> 그럼 언두로그에도 복사되어야 하는데, 언두 로그 공간도 당연히 100GB가 되는것이다.
> 이와 같은 대용량 작업 뿐 아니라 트랜잭션이 오랜 시간 실행될 때에도 언두 로그 양은 급격히 증가한다.


![[Pasted image 20240521123638.png]]

여기 트랜잭션 A, B, C가 있다.
A 트랜잭션이 아직 활성상태인데, B, C는 진작에 끝났다.
그럼에도 A가 아직 활성상대이기 때문에 B, C가 끝났는지 안끝났는지 상관없이 B, C가 만든 언두 로그는 삭제되지 않는다.
따라서 언두 로그의 양이 급격하게 증가하는 것이다.



### 4.2.9.2 언두 테이블스페이스 관리

#언두_테이블스페이스 : 언두 로그가 저장되는 공간


![[Pasted image 20240521123959.png]]

