```table-of-contents
```



# 4.1 MySQL 엔진 아키텍처

MySQL 서버는 다른 DBMS에 비해 독특한 편
사용자 입장에서는 별 차이 못 느낄 수 있으나
독특한 구조로 다른 DBMS와 다르게 엄청난 혜택을 누릴 수가 있음!
반면에 다른 DBMS에서는 문제되지 않을 게 문제되기도 함(...)

## 4.1.1  MySQL의 전체 구조

![[Pasted image 20240515022551.png]]

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분!



### 4.1.1.1 MySQL 엔진
(커넥션 핸들러) 클라이언트로부터 접속 및 쿼리 요청
(옵티마이저) SQL 파서, 전처리기, 쿼리 최적화


4.1.1.2 스토리지 엔진






### 4.1.2.2 백그라운드 스레드
MyISAM은 별로 해당사항이 없지만 InnoDB는 여러 작업이 백그라운드로 처리
* 인서트 버퍼(insert buffer)를 병합하는 스레드
* 로그를 디스크로 병합하는 스레드
* InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
* 데이터를 버퍼로 읽어 오는 스레드
* 잠금이나 데드락을 모니터링 하는 스레드

데이터 쓰기/읽기 스레드 개수 2개 이상 지정 가능
innodb_write_io_threads, innodb_read_io_thread으로 지정

데이터 쓰기는 지연될 수 있음,
데이터 읽기는 지연될 수 없음. (SELECT 실행하면 10분 뒤 결과 알려드림 -> 이런 건 없다)

쓰기 작업은 버퍼링해서 일괄처리, InnoDB 포함.
그러니 MyISAM은 사용자 스레드가 쓰기까지 함께 처리


## 4.1.3 메모리 할당 및 사용 구조

![[Pasted image 20240515023822.png]]

mysql이 사용하는 메모리 공간 -> 글로벌 메모리 영역 vs 로컬 메모리 영역

글로벌 메모리 : mysql 서버 시작 시 운영체제로부터 할당


### 4.1.3.1 글로벌 메모리 영역
클라이언트 스레드 수와 무관하게 1개 메모리 공간만 할당 (필요에 따라 2개 이상도 가능, 단 클라이언트 스레드 수와는 무관)

모든 스레드에 의해 공유

* 테이블 캐시
* InnoDB 버퍼 풀
* InnoDB 어댑티브 해시 인덱스
* InnoDB 리두 로그 버퍼



### 4.1.3.2 로컬 메모리 영역
= 세션 메모리 영역 = 클라이언트 메모리 영역
클라이언트 커넥션으로부터 요청을 처리하기 위해 스레드 하나씩 담당

각 클라이언트 스레드별로 독립 할당 / 절대 공유되지 않음

* 정렬 버퍼(Sort Buffer)
* 조인 버퍼
* 바이너리 로그 캐시
* 네트워크 버퍼



## 4.1.4 플러그인 스토리지 모델

![[Pasted image 20240515024623.png]]


mysql의 독특한 구조, 플러그인 모델

여러 스토리지 엔진을 플러그인 형태로 추가해서 사용함


![[Pasted image 20240515024852.png]]

거의 대부분이 MySQL 엔진 처리 영역에서 처리
마지막 데이터 읽기/쓰기만 스토리지 엔진에 의해 처리

MySQL 서버에서 mysql 엔진은 사람 역할을, 각 스토리지 엔진은 자동차 역할을,
mysql 엔진이 스토리지 엔진을 조정하기 위해 핸들러라는 걸 사용함

핸들러가 뭔지 몰라도 됨. mysql 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나
저장하도록 명령하려면 핸들러를 거처야 한다는 것만 기억하도록.



## 4.1.5 컴포넌트

MySQL 8.0 부터는 기존의 플러그인 아키텍처를 대체하기 위한 컴포넌트 아키텍처가 도입


플러그인 단점
* 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인 끼리는 불가
* 플러그인은 MysQL 서버의 변수나 함수를 직접 호출, 안전하지 않음, 캡슐화 X
* 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움

비밀번호 검증 기능 -> 기존에는 플러그인 형태로 제공됨
반면 8.0 부터는 컴포넌트로 개선


## 4.1.6 쿼리 실행 구조

![[Pasted image 20240515030547.png]]

### 4.1.6.1 쿼리 파서
사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리
이후 트리 형태의 구조로 변환
기본 문법 오류는 이 단계에서 발견 및 에러 메시지 전달


### 4.1.6.2 전처리기
파서 과정에서 만들어진 파서 트리가 쿼리 문장에 구조적 문제가 있는지 확인
각 토큰을 테이블 이름, 칼럼 이름, 내장 함수와 개체를 매핑, 존재 여부와 접근 권한 확인


### 4.1.6.3 옵티마이저
쿼리 문장을 저렴한 비용으로 가장 빨리 처리할지 결정, DBMS의 두뇌


### 4.1.6.4 실행 엔진
옵티마이저 -> 두뇌
실행엔진 / 핸들러 -> 손, 발

옵티마이저가 Group By를 처리하기 위해 임시 테이블을 사용한다고 결정했다하자
1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자 or 다른 모듈로 넘김

즉 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청 + 받은 결과를 또 다른 핸들러 요청의 입력으로 연결


### 4.1.6.5 핸들러 (스토리지 엔진)
핸들러는 mysql 서버의 가장 밑단에서 mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장 or 읽어옴
myisam 테이블을 조작할 경우 핸들러가 myisam 스토리지 엔진이 됨
innodb 테이블을 조작할 경우 핸들러가 innodb 스토리지 엔진이 됨


## 4.1.7 복제
복제는 매우 중요한 역할을 담당한다. 별도의 장에서 살펴본댄다. 넘어간다.


## 4.1.8 쿼리 캐시
쿼리 캐시(Query Cache)는 빠른 응답을 필요로 하는 웹 기반 응용 프로그램에서 중요 역할

SQL 실행 결과를 메모리에 캐시, 동일 SQL이 실행되면 테이블을 읽지 않고 결과 반환
듣기만 했는데도 진짜 ㄹㅇ 빨라보이지만

테이블 데이터가 변경되면 이와 연관된 데이터 중 캐시에 저장된건 모두 삭제됨
심각한 동시 처리 성능을 저하 유발 + 많은 버그 원인 -> 결국 삭제 엔딩 8.0



## 4.1.9 스레드 풀(Thread Pool)
서버 엔터프라이즈 에디션 -> 스레드 폴 O
커뮤니티 에디션 -> 스레드 폴 X

스레드 폴은 내부적으로 사용자 요청 처리 스레드 개수를 줄여서,
동시 처리 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 하여 서버 자원 소모를 줄이는 것이 목적

??? : 스레드 풀만 설치하면 성능 두 배쯤 올라가는거 아냐? -> 예끼 이놈!
실제 스레드 풀이 눈에 띄는 성능 향상을 보여준 건 드물었다.

동시 실행 중인 스레드들을 CPU가 최대한 잘 처리하낼 수 있는 수준으로 줄여 빨리 처리하게 하는 기능이기에,
CPU 시간을 제대로 확보하지 못할 경우 오히려 쿼리가 느려지기도 함


CPU의 프로세서 친화도를 높이고 운영체제 입장에서 불필요한 컨텍스트 스위칭을 줄여 오버헤드를 낮출 수 있다


기본적으로 CPU 코어 수 많큼 스레드 그룹을 만드는데, thread_pool_size 변수로 제어
스레드 그룹의 모든 스레드가 일을 처리하고 있다면
스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지,,,
아님 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 판단해야 해

thread_stall_limit 밀리초 만큼 작업 스레드가 지금 처리 중인 작업을 끝내지 못하면 새 스레드를 추가할꺼야

즉, 모든 스레드가 모두 일하는 중일 때 새 요청이 들어와도 thread_stall_limit 시간 만큼 기다려야 새 요청을 처리할 수 있다는 이야기. 따라서 응답 시간에 아주 예민하다면 적절하게 낮추자. 하지만 0에 가까운 값에 설정하는 건 권장하지 않아. 0에 가깝다면 스레드 풀을 사용하지 않는 편이 나을 것이기에.



### 4.1.10 트랜잭션 지원 메타 데이터
테이블의 구조 정보와 스터오드 프로그램 등의 정보를 데이터 딕셔너리 or 메타데이터라 함
5.7 버전까지 FRM 파일에 저장했으나 파일 기반 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않음!
테이블 생성 또는 변경 도중 mysql 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남아 있는 문제가 생김 (= DB or 테이블이 깨졌다)

때문에 관련 정보를 모두 InnoDB 테이블에 저장하도록 개선
모두 트랜잭션 기반이기에 mysql 서버가 중간에 비정상 정료 되더라도 스키마 변경이 완전 성공 or 완전 실패로 정리

ACID? 원자성과 관련 있는듯



# 4.2 InnoDB 스토리지 엔진 아키텍처

![[Pasted image 20240515160430.png]]

mysql 스토리지 엔진 중 가장 많이 사용되는 건 InnoDB 이다
그러타! mysql 스토리지 엔준 중 거의 유일하게 레코드 기반 잠금을 지원한다!
그러타! 높은 동시성 처리가 가능하다! 성능이 뛰어나다!



## 4.2.1 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장
-> 프라이머리 키 값의 순서대로 디스크에 저장
-> 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용

pk를 기준으로 클러스터링 되니까 당연히 pk 이용 레인지 스캔은 빠르겠죵?
따라서 pk는 다른 보조 인덱스에 비해 비중이 높게 설정

InnoDB와는 달리 MyISAM에서는 클러스터링 키 지원 X
-> 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다
그냥 유니크 제약을 가진 세컨더리 키일 뿐



## 4.2.2 외래 키 지원
MyISAM이나 MEMORY 테이블에서는 외래키는 안된다. InnoDB에서만 가능하다.

외래 키는 DB 서버 운용 불편함 때문에 서비스용 데이터 베이스에서는 사용하지 않는 경우도 있다.
InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요함
변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크해야 하는 작업이 필요
-> 잠금이 여러 테이블로 전파, 데드락 발생 가능성 UP

긴급하게 조치를 해야 하는데 외래키가 얽힌 경우 머리 터질 수도 있음
foregin_key_chekcs를 off로 하면 외래키 관계에 대한 작업을 일시적 비활성화 가능



## 4.2.3 MVCC(Multi Version Concurrency Control)
레코드 레벨 트랜잭션 -> 일반적으로 DBMS가 지원
MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있음

![[Pasted image 20240515162559.png]]

![[Pasted image 20240515162603.png]]


![[Pasted image 20240515162650.png]]
![[Pasted image 20240515162654.png]]

UPDATE 문장 실행 -> 커밋 실행 여부와 상관 없이 버퍼 풀은 업데이트

그런데!!! 아직 commit or rollback 되지 않은 상황에서 다른 사용자가 조회하면 어디에 있는 걸 조회하나?

정답은 transaction_isolation에 설정된 격리 수준(Isolation level)에 따라 다르다! (두둥 - 탁!)

READ_UNCOMMITED -> InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어 반환
READ_COMMIT or 그 이상(REPLATABLE_READ, SERIALIZABLE) -> 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경 이전 내용을 보관하고 있는 언두 영역 데이터 반환 ㄴ ㅇㅁㅇ ㄱ
DBMS에서는 MVCC 라고 표현


## 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
INSERT와 연결되지 않는 순수 읽기(SELECT) 작업은 다른 트랜잭션 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다!

특정 사용자가 레코드 변경 ~ 커밋 수행함과 관련 없이 다른 사용자의 SELECT 작업을 방해하지 않음
이를 '잠금 없는 일관된 읽기' 라고 한다


## 4.2.5 자동 데드락 감지
InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해
잠금 목록을 그래프(wait-for-list) 형태로 관리

데드락 감지 스레드를 가지고 있어서 얘가 주기적으로 잠금 대기 그래프를 검사해
교착 상태에 빠진 트랜잭션 검사하고 그 중 하나 강제 종료함

어느 걸 먼저 강제 종료 할 건지 판단 기준은 트랜잭션 언두 로그 양,
언두 로그 레코드를 적게 가질수록 일반적으로 롤백 대상
(언두 레코드가 적다는 건 언두 처리할 내용이 적다는 거고 강제 롤백 새 서버 부하가 적다는 것이기 때문)

일반적인 서비스에서는 데드락 감지 스레드가 트랜잭션 잠금 목록 검사 후 데드락 찾아내는 작업은 그리 부담되지는 않음
하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금 개수가 많아지면 데드락 감지 스레드가 느려짐

데드락 감지 스레드는 잠금 목록을 검사해야 하기 때문에
잠금 목록 저장 리스트에 새로운 잠금을 걸고 데드락 스레드를 찾음

데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기 -> 서비스에 악영향
동시 처리 스레드가 매우 많아지면 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있음


## 4.2.6 자동화된 장애 복구

InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 매커니즘 탑재! 와!

mysql 서버 시작될 때 완료되지 못한 트랜잭션 or 일부만 기록된 페이지 -> 복구 작업 자동 실행

데이터 파일 손상 or mysql 서버가 시작되지 못하는 경우는 거의 없으나
디스크나 서버 하드웨어 이슈로 InnoDB가 자동 복구 못할수도 있다,,,
일 단 한 번 문제가 생기면 복구 쉽지 않아서 복잡하다고 보면 된다.
자동복구 못하고 그냥 종료되어 버림

이럴땐 innodb_force_recovery 변수로 mysql 서버 시작해야함

* InnoDB의 로그 파일이 손상됬다면 6으로 설정하고 mysql 서버 기동
* InnoDB 테이블의 데이터 파일이 손상됬다면 1로 설정하고 mysql 서버 기동
* 어떤게 문젠지 모른다면 1~6까지 변경하면서 서버 재시작
	* 참고로 숫자가 커질수록 심각한거다... 데이터 손실 가능성 UP, 복구 가능성 DOWN


innodb_force_recovery
* 1 (SRV_FORCE_IGNORE_CORRUPT)
	* InnoDB 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분 발견해도 무시 + 서버 시작
* 2 (SRV_FORCE_NO_BACKGROUND)
	* InnoDB 쿼리 처리를 위해 여러 종류 백그라운드 스레드 동시 사용, 메인 스레드 시작하지 않고 mysql 서버 실행
* 3 (SRTV_FORCE_NO_TRX_UNDO)
	* InnoDB 트랜잭션이 실행되면 롤백에 대비해 변경 전의 데이터를 언두 영역에 기록
	* mysql 서버는 다시 시작하면서 언두 영역 데이터를 먼저 데이터 파일에 적용 + 그 다음 리두 로그 내용을 덮어써서 장애 시점 데이터 상태를 만들어냄
	* 정상 mysql 서버에서는 최종적으로 커밋되지 않은 트랜잭션은 롤백하지만 3단계에서는 롤백 x 그대로 납둠 o
* 4 (SRV_FORCE_NO_ UNDO_LOG_SCAN)
	* INSERT, UPDATE, DELETE 등 데이터 변경으로 인한 인덱스 변경 작업을 상황에 따라 즉시 처리할 수도 있고 인서트 버퍼에 저장해두고 나중에 처리할 수도 있음
	* 4단계에서는 인서트 버퍼 내용을 무시 + 강제로 mysql 시작
* 5 (SRV_FORCE_UNDO_LOG_SCAN)
	* mysql 서버가 장애 or 정상적 종료 시점 진행 중인 트랜잭션이 있다면 mysql은 그냥 단순히 커넥션을 끊고 별도 정리 없이 그냥 종료함. 재실행 시 언두 레코드를 이용해 데이터 페이지를 복구 및 리두 로그를 적용하여 장애 or 종료 시점 재현. innodb는 마지막으로 커밋되지 않은 트랜잭션은 모두 롤백처리. 그런데 innodb 언두 로그를 사용할 수 없다면 mysql 실행 불가
	* 이 때 5단계로 설정하면 스토리지 엔진을 모두 무시하고 mysql 엔진 실행 가능
	* 종료 시점 커밋되지 않았던 작업도 모두 커밋된 것 처럼 처리되므로 잘못된 데이터가 db에 남는 것으로 볼 수 있음
* 6 (SRV_FORCE_NO_LOG_REDO)
	* innodb 스토리지 엔진의 리두 로그가 손상되면 mysql 서버가 실행되지 못함
	* 6단계에서는 리두 로그를 모두 무시한 채 mysql 서버 실행
	* 커밋됬다 하더라도 리두 로그에만 기록되고 데이터 파일에 기록되지 않았다면 모두 무시



## 4.2.7 InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
쓰기 작업 지연을 통한 일괄 작업으로 처리할 수 있게 해주는 버퍼역할도 같이 함

데이터 변경 쿼리(UPDATE/INSERT/DELETE) 등은 데이터베이스 이곳저곳을 변경
-> 랜덤한 디스크 작업 발생

하지만 버퍼풀이 출동한다면?
-> 변경된 데이터를 모아 처리하기 때문에 랜덤한 디스크 작업 횟수를 줄일 수 있다



### 4.2.7.1 버퍼 풀의 크기 설정

일반적으로 전체 물리 메모리의 80% 정도를 InnoDB 버퍼풀로 설정하라 -> X
그렇게 단순하게 설정하면 안됨.

고려요소 : **운영체제, 각 클라이언트 스레드가 사용할 메모리**

MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없으나,
아주 독특한 경우 레코드 버퍼가 상당한 메모리를 잡아먹기도 함.

#레코드_버퍼  : 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 사용하는 버퍼.

커넥션이 많고 사용하는 테이블이 많다 -> 레코더 버퍼 용도로 사용되는 메모리 공간이 많이 필요해질 수도 있음
MySQL 서버가 사용하는 레코드 버퍼 공간 -> 별도로 설정 할 수 없다.
전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블의 개수에 따라 결정됨

mysql 5.7 부터는 InnoDB의 버퍼 풀 크기를 동적으로 조절 할 수 있게됨
InnoDB 버퍼 풀 크기를 적절히 낮은 값으로 설정해서 조금씩 올리는게 최적!


> 운영체제의 메모리가 8GB 미만이라면 50% 정도만 InnoDB 버퍼 풀로 설정하고,
> 그 이상이라면 50%에서 시작해 조금씩 올려가며 최적점을 찾자.


InnoDB 버퍼 풀은 innodb_buffer_pool_size로 설정하며 동적으로 지정가능
다만, 크리티컬 변경이므로 mysql 서버가 한가할 때 하자.
버퍼 풀을 크게 하는 건 별 문제가 없으나, 줄이면 서비스 영향이 매우 크게 간다.

InnoDB 버퍼 풀은 세마포어로 내부 잠금 경합을 유발했다.
경합을 줄이기 위해 버퍼 풀을 여러 개로 쪼개어 관리할 수 있게 개선하였으며,
innodb_buffer_pool_instance 시스템 변수로 여러 개로 분리해 관리 가능.

각 버퍼 풀을 버퍼 풀 인스턴스라고 표현.
1GB 미만이라면 버퍼 풀 인스턴스는 1개로 초기화, 이상이라면 기본적으로 8개로 초기화



### 4.2.7.2 버퍼 풀의 구조

InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기 조각으로 쪼개어 필요 시 마다 페이지를 읽는다.

크기 조각을 관리하기 위해
* LRU (Least Recently Used) 리스트 : 아래 그림 참조
* 플러시 (Flush) 리스트
* 프리 (Free) 리스트 : InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 빈 페이지 목록
3개 자료 구조를 관리.



![[Pasted image 20240520181937.png]]


LRU 리스트는 엄밀하게는 LRU와 MRU(Most Recently Used)가 결합된 형태라 할 수 있음
Old 서브리스트 영역은 LRU, New 서브리스트 영역은 MRU로 보면 된다

리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오래 기억하고 있음으로써 디스크 읽기를 최소하는 것이다.


#InnoDB_스토리지_엔진에서_데이터를_찾는_과정 

필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
A. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
B. 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색
C. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 LRU 헤더 부분에 추가
디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가

버퍼 풀에 상주한 데이터는 최근 접근에 따라 나이(Age) 부과
상주할 동안 나이를 먹고(Aging) 수명을 넘기면 자연사함
쿼리에 의해 사용되면 0살로 다시 회춘함



#플러시리스트  : 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지) 변경 시점 기준 목록 관리

디스크에서 읽은 뒤 변경이 없다 -> 플러시 리스트에 관리 X
한 번 데이터 변경이 가해짐 -> 플래시 리스트에서 관리

변경되면 리두 로그에 기록 후 버퍼 풀의 데이터 페이지에도 변경 내용 반영





### 4.2.7.3 버퍼 풀과 리두 로그

InnoDB 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정할수록 쿼리의 성능이 빨라진다
(단, 이미 디스크의 모든 데이터 파일이 버퍼 풀에 적재될 정도의 공간이라면 늘린다고 더 빨라지진 않는다)


![[Pasted image 20240520202235.png]]


InnoDB 버퍼 풀은 데이터베이스 서버 성능 향상 용도
* 데이터 캐시
* 쓰기 버퍼링
참고로 버퍼 풀의 메모리 공간만 늘리는던 데이터 캐시 기능만 향상키는 것.


InnoDB의 버퍼 풀
* 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지와
* 변경된 데이터를 가진 더티 페이지가 있다.
	* 변경됐으므로 언젠간 디스크로 기록되야 한다
	* 하지만 버퍼 풀에 무한정 머무를 순 없다

리두 로그는 1개 이상의 고정 파일을 연결하여 순환 고리처럼 사용하며
데이터 변경이 계속 발생하면 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다.
따라서 InnoDB는 전체 리두 로그 파일에서 재사용 가능, 당장 재사용 불가능한 공간을 구분해 관리
여기서 재사용 불가능한 공간을 활성 리두 로그라고 한다.


LSN(Log Sequence Number) : 리두 로그 파일 공간은 계속 재사용되나, 기록될 때 마다 포지션은 증가. 이를 LSN이라 함


리두 로그 - 버퍼 풀 더티 페이지 동기화
- 주기적으로 체크포인트 이벤트 발생
- 가장 최근 체크포인트 지점이 LSN 활성 리두 로그 공간의 시작점
- 가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN 차이를 체크포인트 에이지라 함
	- 항상 활성 리두 공간의 크기를 의미



### 4.2.7.4 버퍼 풀 플러시(Buffer Pool Flush)

InnoDb는 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지를 동기화 하기 위해 2개 플러기 기능을 백그라운드에서 실행한다
* 플러시 리스트 플러시
* LRU 리스트 플러시


#### 4.2.7.4.1 플러시 리스트 플러시

리두 로그 공간을 재활용하려면? 주기적으로 리두 로드 엔트리 공간을 비워야겠죠?
플러시 리스트 플러시 함수를 호출하여 변경된 페에지를 동기화할 수 있습니다!

InnoDB는 다음과 같은 시스템 변수를 제공함
* innodb_page_cleaners
	* 클리너 스레드의 개수 조정
	* 클리너 스레드 : 더티 페이지를 디스크로 동기화 하는 스레드
	* 설정값이 버퍼 풀 인스턴스 보다 많다면 innodb_buffer_poll_instances로 자동 변경
* innodb_max_dirty_pages_pct
	* 더티 페이지 비율 조정
	* 더티 페이지를 많이 가지고 있을수록 디스크 쓰기 작업을 버퍼링 -> 여러 번 디스크 쓰기를 한 번으로
* innodb_max_dirty_pages_pct_lwm
	* 더티 페이지가 많으면 디스크 쓰기 폭발 가능성 있음
	* 일정 수준의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록하게 하는 변수
* innodb_io_capacity
	* 데이터베이스 서버에서 어느 정도의 디스크 읽고 쓰기가 가능한지 결정
	* 여기서 디스크 읽고 쓰기는 백그라운드 스레드가 수행하는 디스크 작업을 의미 (대부분 더티 페이지 쓰기)
* innodb_io_capacity_max
	* 디스크가 최대 성능을 발휘할 때 어느 정도의 디스크 읽고 쓰기가 가능한지 설정
* innodb_flush_neighbors
	* 더티 페이지를 디스크에 기록 시 근접한 페이지 중 더티 페이지가 있다면 함께 묶어 디스크로 기록
	* 한 번이라도 디스크 읽기 쓰기를 줄이기 위한 노력의 결과임
	* SSD에서는 기본값인 비활성 모드로 유지 권장
* innodb_adaptive_flushing
	* 어댑티브 플러시 사용 유무 (기본값 : 사용)
	* 활성화되면 InnoDB는 단순히 버퍼 풀의 더티 페이지 비율 / 위 환경변수값에 의존하지 않고 새로운 알고리즘 사용
	* 더티 페이지를 어느정도 기록해야 할까요?
		-> 리두 로그가 어느 정도 속도로 증가하는지를 분석하는 것과 같다
		리두 로그의 증가 속도 분석하여 -> 적절 수준 더티 페이지가 버퍼 풀에 유지할 수 있게 함
* innodb_adaptive_flushing_lwm
	* 기본값 : 10%, 10% 이상일 때 어댑티브 플러시 알고리즘 작동



#### 4.2.7.4.2 LRU 리스트 플러시
LRU 리스트 플러시 함수 : LRU 리스트에서 사용 빈도가 낮은 데이터 페이지를 제거하여 공간마련

범위 : LRU 리스트 끝부분부터 시작 ~ 최대 innodb_lru_scan_depth 개수만큼 스캔

스캔하면더 더티 페이지는 디스크에 동기화



### 4.2.7.5 버퍼 풀 상태 백업 및 복구

워밍 업 : 디스크의 데이터가 버퍼 풀에 적재되 있는 상태. 잘 워밍업 되어있으면 그렇지 않은 경우보다 몇십 배 쿼리 처리 속도를 보임

5.6 부터 버퍼 풀 덤프 및 적재 기능이 도입되어
재시작 할 경우 innodb_buffer_pool_dump_now로 InnoDB 버퍼 풀의 상태 백업 가능

ib_buffer_pool 이라는 이름으로 백업
* 메타 정보만 저장하므로 백업은 매우 빠름
* 읽을땐 오래걸림. 백업 내용에서 각 테이블의 데이터 페이지를 다시 디스크에서 읽기 때문
* 너무 오래걸려서 멈추려면 innodb_buffer_pool_load_abort 사용



### 4.2.7.6 버퍼 풀의 적재 내용 확인

information_schema 데이터베이스의 innodb_buffer_page 테이블로 InnoDB 버퍼 풀의 메모리에 어떤 테이블의 페이지들이 적재되어있는지 확인
-> 테이블 조회가 상당히 큰 부하를 일으켜 서비스 쿼리가 많이 느려짐

8.0 버전부터 information_schema 데이터베이스에 추가된 innodb_cached_indexs 테이블로 데이터 페이지가 얼마나 innodb 버퍼 풀에 적재되 있는지 확인 가능



## 4.2.8 Double Write Buffer

파셜 페이지 / 톤 페이지 : 더티 페이지를 디스크 파일로 플러시 할 때 일부만 기록되는 현상

Double-write : 파셜 페이지 / 톤 페이지를 피하기 위해 사용되는 기법

![[Pasted image 20240521101655.png]]


1. InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에 A~E 데이터를 묶어 한 번의 디스크 쓰기로 테이블 스테이스의 DoubleWrite 버퍼에 기록
2. 각 더티 페에지를 파일의 적당한 위치에 하나씩 랜덤 쓰기
3. DoubleWrite 버퍼 공간에 기록된 변경 내용은 더 이상 쓸모가 없어짐

DoubleWrite 기능 사용 여부는 innodb_doublewrite로 제어




## 4.2.9 언두 로그

InnoDB는 트랜잭션과 격리 수준 보장을 위해 INSERT/UPDATE/DELETE 전 데이터를 백업함
백업된 데이터를 언두 로그(Undo Log) 라고 함

#언두_로그 InnoDB는 트랜잭션과 격리 수준 보장을 위해 INSERT/UPDATE/DELETE 전 데이터를 백업함
백업된 데이터를 언두 로그(Undo Log) 라고 함
* 트랜잭션 보장
	* 트랜잭션 롤백 시 변경된 데이터를 복구해야함
* 격리 수준 보장
	* 특정 커넥션에서 데이터를 변경하는 도중 다른 커넥션에서 데이털르 조회해도, 격리 수준에 맞게 변경중인 레코드를 읽지 않고도 언두 로그에 백업된 데이터를 읽어 반환하기도 함


### 4.2.9.1 언두 로그 레코드 모니터링

> mysql> UPDATE member SET name = '홍길동' WHERE member_id=1;

위 문장이 실행되면 트랜잭션 커밋 전에도 데이터파일(인덱스버퍼)는 '홍길동'으로 변경됨
커밋하게 된다면? -> 그대로 유지
롤백하면? -> 언두 영역 백업된 데이터를 복구

언두 로그 데이터의 용도
1. 위에서 언급한 트랜잭션 롤백 대비용
2. 트랜잭션 격리 수준을 유지 + 높은 동시성


> 자, DLEETE로 100GB 크기의 테이블을 삭제한다고 하자
> 그럼 언두로그에도 복사되어야 하는데, 언두 로그 공간도 당연히 100GB가 되는것이다.
> 이와 같은 대용량 작업 뿐 아니라 트랜잭션이 오랜 시간 실행될 때에도 언두 로그 양은 급격히 증가한다.


![[Pasted image 20240521123638.png]]

여기 트랜잭션 A, B, C가 있다.
A 트랜잭션이 아직 활성상태인데, B, C는 진작에 끝났다.
그럼에도 A가 아직 활성상대이기 때문에 B, C가 끝났는지 안끝났는지 상관없이 B, C가 만든 언두 로그는 삭제되지 않는다.
따라서 언두 로그의 양이 급격하게 증가하는 것이다.



### 4.2.9.2 언두 테이블스페이스 관리

#언두_테이블스페이스 : 언두 로그가 저장되는 공간


![[Pasted image 20240521123959.png]]

5.6 이전 : 언두 로그가 모두 시스템 테이블스페이스에 저장. 서버가 초기화될 때 생성되기에 확장에 한계
5.6 -> innodb_undo_tablespaces 변수 도입, 2 보다 크게 설정하면 언두 로그를 별도를 언두 로그 파일에 저장
(0일때는 여전히 시스템 테이블스페이스)
8.0 이후 : innodb_uno_tablespace는 deprecated 됨. 언두는 항상 세스템 테이블스페이스 외부에 별도 로그 파일에 기록

Undo tablespace truncate : 언두 테이블스페이스 공간을 필요한 만큼만 남기고 불필요/과도하게 할당된 공간을 운영체제에게 반납
* 자동모드 : 트랜잭션이 데이터를 변경하면 이전 버전의 데이터를 언두 로그에 기록. 커밋이 되면 더 이상 언두 로그에 복사된 이전 값은 불필요해짐. innodb 퍼지 스레드는 주기적으로 깨어나 언두 로드 삭제 (이걸 언두 퍼지라 함)
* 수동모드 : innodbn_undo_log_truncate가 off로 되어있을 경우 언두 테이블 스페이스를 비활성화하여 퍼지 스레드는 비활성 상태의 언두 테이블 스페이스를 찾아서 불필요한 공간을 잘라내고 운영체제로 해당 공간 반납



## 4.2.10 체인지 버퍼

레코드가 삽입/갱신될 때 인덱스도 업데이트 해야함
인덱스 업데이트는 랜덤 디스크 읽기 작업이 필요함
많으면 상당히 많은 자원 소모

변경할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트하나,
디스크로부터 읽어와서 업데이트해야 한다면
이를 즉시 실행하지 않고 임시 공간에 두고 사용자에게 결과 반환하여 성능 향상
-> 체인지 버퍼라 함



#체인지_버퍼_머지_스레드 : 결과 전달 전 반드시 중복 여부를 체크해야 하는 유닉스 인덱스는 체인지 버퍼 사용할 수 없고 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합

8.0 이상부터는 insert, delete, update로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링이 가능

5.5 부터 innodb_change_buffering가 도입되어 작업별로 체인지 버퍼 활성화 가능
* all : inserts + deletes + purges 버퍼링
* none : 아무것도 X
* inserts : 인덱스에 새 아이템 추가 작업만 버퍼링
* deletes 인덱스에 삭제하는 작업만 버퍼링
* changes : inserts + deletes
* purges : 인덱스 아이템을 영구적으로 삭제하는 작업만 버퍼링

체인지 버퍼는 기본적으로 25%만 사용할 수 있도록 설정
필요하다면 50%까지 사용하도록 설정 가능
더 많은 버퍼 풀을 사용할 수 있게 하고자 한다면 innodb_change_buffer_max_size 설정



## 4.2.11 리두 로그 및 로그 버퍼

리두 로그는 ACID 중에서 D(Durable)에 해당하는 영속성과 밀접
| 왜냐하면 하드/소프트웨어 등 여러 문제점으로 mysql 서버 비정상 종료 시 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치기 때문

mysql 서버를 포함한 대부분 db 서버는 데이터 변경 내용을 로그로 먼저 기록함
-> 쓰기보단 읽기 성능을 고려했기 때문임
-> 파일 쓰기는 랜덤 엑세스 필요, 따라서 변경된 데이터를 기록하려면 상대적으로 비용이 크다!

위 문제로 인한 성능 저하를 막기 위해 db 서버는 쓰기 비용이 낮은 자료 구조를 가진 리두 로그를 가짐
-> 비정상 종료 발생 시 리두 로그 내용을 이용, 종료 직전 상태로 데이터 파일 복구


mysql 서버 비정상 종료 시 innodb 가 가질 수 있는 일관되지 않은 데이터는 두 종류
* 커밋됐지만 데이터 파일에 기록되지 않은 데이터
	* 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하면 끝
* 롤백됐지만 데이터 파일에 이미 기록된 데이터
	* 리두 로그로는 해결 불가, 변경되기 전 언두 로그를 가져와 복사
	* 다만 리두 로그가 전혀 필요하지 않은 것은 아님

innodb_flush_log_at_trx_commit : 리두 로그를 어느 주기로 디스크에 동기화할지 적용
* innodb_flush_at_trx_commit = 0
	* 1초에 1번씩 리두 로그 기록/동기화 실행
* innodb_flush_at_trx_commit = 1
	* 매 트랜잭션 커밋마다 디스크 기록 및 동기화
	* 트랜잭션이 일단 커밋되면 해당 트랜잭션에서 변경한 데이터는 삭제됨
* innodb_flush_at_trx_commit = 2
	* 매 트랜잭션 커밋마다 기록, 단 동기화는 1초에 1번씩
	* 일단 트랜잭션이 커밋되면 변경 내용이 운영체제의 메모리 버퍼로 기록되는게 보장
	* mysql 서버가 비정상종료되도 트랜잭션의 데이터는 유지
	* 단, 운영체제까지 말썽이면 1초동안의 데이터는 사라질 수도 있음



### 4.2.11.1 리두 로그 아카이빙

8.0부터 리두 로그를 아카이빙 할 수 있는 기능이 추가되었다.

mysql 엔터브라이즈 백업이나 Xtrabackup 툴은 데이터 파일을 복사하는 동안 innodb에 쌓인 내용을 추적 +
새로 추가된 리두 로그 엔트리 복사함

복사하는 동안 축사된 리두 로그 엔트리가 같이 백업되지 않는다면 복사된 데이터 백업 파일은 일관된 상태를 유지하지 못함
mysql 서버에 유입되는 데이터 변경이 너무 많으면 리두 로그가 매우 빠르게 증가하고, 엔터프라이즈 백업이나 xtrabackup이 새로 추가되는 리두 로그 내용을 복사하기도 전에 덮어쓰일 수도 있기 때문
아직 복사하지 못한 리두 로그가 덮어쓰이면 백업 툴이 리두 로그 엔트리를 복사할 수 X -> 백업 실패

8.0의 리두 로그 아카이빙 기능은 데이터 변경이 많아서 리두 로그가 덮어쓰여도 백업 실패를 막아줌
innodb_redo_log_archive_dirs : 리두 로그 아카이빙 사용 유무 설정

디렉터리 준비 완료
-> innodb_redo_log_archive_start UDF 실행
-> 1개 또는 2개 파라미터 입력
	* 첫 번째 파라미터: 아카이빙할 디렉터리에 대한 레이블
	* 두 번째 파라미터(선택) 서브디렉터리 이름

innodb_redo_log_archive_start UDF를 실행한 세션이 계속 연결이 유지되야 리두 로그 아카이빙이 계속 실행됨
연결이 끊어진다면 아카이빙을 멈추고 파일도 자동으로 삭제
반드시 정상종료해야함



### 4.2.11.2 리두 로그 활성화 및 비활성화

리두로그는 트랜잭션 복구를 위해 항상 활성화되어있음
mysql 서버에서 트랜잭션 커밋 시
* 데이터 파일 -> 즉시 디스크 동기화
* 리두 로그(트랜잭션 로그) -> 항상 디스크로 기록

8.0 이전 -> 수동으로 리두 로그 비활성화 방법 X
8.0 이후 -> ALTER INSTANCE [ ENABLE | DISABLE ]로 제어

리두 로그가 비활성화 되면...
mysql 서버가 비정상 종료되면 마지막 체크포인트 이후 시점 데이터는 복구 X
더 큰일난건 마지막 체크포인트 시점이 일관된 상태가 아닐수도 있다는 점임
ex> 마지막 체크포인트 10시 정각 실행, 10시 1분 비정상 종료
-> 리두 로그가 없다면 재시작된 mysql 서버는 10시 정각 ~ 10시 1분까지 다양한 시점의 데이터를 골구로 갖게 됨


그니까 용건이 끝났다면 다시 활성화하는걸 잊지 말자구!!!



## 4.2.12 어댑티브 해시 인덱스

>인덱스 : 일반적으로 테이블에 사용자가 생성해둔 B-Tree 인덱스를 의미

B-Tree 알고리즘 말고도 사용자가 직접 테이블에 생성해둔 인덱스를 일반적으로 알고 있지만
여기서 언급하는 '어댑티브 해시 인덱스'는 수동 생성 인덱스가 아닌 innodb에서
사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스임
innodb_adaptive_hash_index로 끔/켬 가능

B-Tree는 일반적으로 매우 빠르다고 알고 있다.
하지만 빠르다는건 어디까지나 상대적이다.
DB 서버가 얼마나 많은 일을 하냐에 따라 B-Tree에서 인덱스를 찾는게 느릸도 있고 빠를 수도 있다.

> B-Tree 인덱스에서 특정 값을 찾기 위해서는?
> B-Tree 루트 -> 브랜치 노드 -> 리프 노드로 찾아가야 함

몇 천개의 스레드로 실행하면 자연히 쿼리 성능은 낮아짐
어댑티브 해시 인덱스는 이렇나 B-Tree 검색 시간을 줄여주기 위해 도입
자주 읽히는 키 값을 이용해 해시 엔덱스 생성
-> 필요할 때 마다 어댑티브 해시 인덱스를 검색
-> 레코드가 저장된 데이터 페이지 즉시 찾음
-> B-Tree를 루트~리프노드까지 찾는 비용 없어짐 -> 빠름!

어댑티브 해시 인덱스가 도움이 되지 않는 경우
* 디스크 읽기가 많은 경우
* 특정 패턴의 쿼리가 많은 경우 (Join, Like 패턴 검색)
* 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

성능 향상에 많은 도움을 주는 경우
* 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
* 동등 조건 검색(동등 비교와 IN 연산자)이 많은 경우
* 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우



## 4.2.13 InnoDB, MyISAM MEMORY 스토리지 엔진 비교

MyISAM 스토리지 엔진은 점차 도태되는 상태이며,
MEMORY 스토리지 엔진은 메모리라는 이름때문에 과대평가를 받곤 함
하나의 스레드에서만 데이터를 읽고 쓴다면 InnoDB보다 빠를수야 있겠지만
동시 처리 성능은 InnoDB를 못따라감



## 4.3 MyISAM 스토리지 엔진 아키텍처

![[Pasted image 20240522014014.png]]


## 4.3.1 키 캐시

MyISAM 키 캐시(Key Cache) : InnoDB 버퍼 풀과 비슷한 역할
다만 이름처럼 인덱스만을 대상으로 작동

key_buffer_size : 키 캐시 공간 설정



## 4.3.2 운영체제의 캐시 및 버퍼

MyISAM 테이블의 인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 충분히 빠르게 검색가능
근데@@ 테이블의 데이터에 대해서는 디스크로부터 I/O를 해결해 줄 만한 어떠한 캐시나 버퍼링 기능도 myisam은 없단말여~
그래서 myisam 테이블의 데이터 읽기나 쓰기 작업은 항상 운영체제의 디스크 읽기/쓰기 작업으로 요청될 수 밖에 없는거제~


## 4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조

InnoDB -> 프라이머리 키에 의해 클러스터링
MyISAM -> 데이터 파일이 힙(Heap) 공간 처럼 활용
즉 프라이머리 키 값과 무관하게 INSERT 되는 순서대로 저장
MyISAM에 저장되는 레코드는 모두 ROWID라는 물리적 주소값을 가짐
프라이머리 키와 세컨더리 인덱스는 모두 레코드의 ROWID 값을 포인터로 가짐

ROWID 저장 방법
* 고정 길이 ROWID
	* 자주 사용 X
	* 최대로 가질 수 있는 레코드가 한정된 테이블을 생성 가능한데, 최대 개수가 한정되면 MyISAM 테이블은 ROWID 값으로 4바이트 정수 사용
* 가변 길이 ROWID
	* 2~7바이트까지 가변적 ROWID 가짐
	* 첫 번째 바이트는 ROWID 길이를 저장하는 용도로 사용
	* 나머지는 실제 ROWID를 저장하는데 사용



# 4.4 MySQL 로그 파일

mysql 서버 상태를 진달할 수 있는 많은 도구가 있지만 많은 지식을 필요로 하기도 함
하지만 로그 파일을 이용하면 mysql 서버 깊은 지식이 없어도 상태나 부하 원인을 쉽게 찾아서 해결할 수 있음


## 4.4.1 에러 로그 파일

에러 로그 파일(이름 : log_error)
* mysql이 시작하는 과정과 과녈ㄴ된 정보성 에러 메시지
* 마지막으로 종료할 때 비정상저그올 종료된 경우 나타나는 innodb 트랜잭션 복구 메시지
* 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
* 비정상적으로 종료된 커넥션 메시지
* innodb의 모니터링 또는 상태 조회 명령(SHOW ENGINE INNODB STATUS 같은)의 결과 메시지
* MySQL의 종료 메시지
등이 담긴다.



## 4.4.2 제네럴 쿼리 로그 파일(제네럴 로그 파일, General log)

가끔 mysql 서버에서 실행되는 쿼리가 뭐가 있는지 전체 목록을 뽑아 검토할 일이 있는데,
쿼리 로그를 활성화하여 쿼리를 기록한 다음 그 파일을 검토하면 된다.

슬로우 쿼리 로그와는 조금 다르게
제네럴 쿼리 로그는 실행되기 전 mysql이 쿼리 요청을 받으면 바로 기록하기에
에러가 나더라도 일단 로그 파일에 기록됨

general_log_file에 저장된다.



## 4.4.3 슬로우 쿼리 로그

mysql 서버 쿼리 튜닝
1. 서비스가 적용되기 전 전체적으로 튜닝
	* 검토해야 할 대상 쿼리가 전부라 모두 튜닝
2. 서비스 운영 중 mysql 서버의 전체적인 성능 저하 검사 or 정기적 점검을 위한 튜닝
	* 어떤 쿼리가 문제의 쿼리인지 판단하기 힘듬

long_query_time 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리가 모두 기록됨
실제 소요시간을 기록해야 하기 때문에 완전이 실행 완료된 쿼리만 기록 가능하다.
즉 기록된 쿼리는 모두 정상적으로 실행 완료된 쿼리이며, long_query_time 보다 적은 시간동안 수행되었다는 것

log_output : 슬로우 쿼리 로그를 파일로 기록 vs 테이블로 기록 선택

![[Pasted image 20240522022612.png]]

* Time : 시작 시간 X 종료시간 O
* User@Host : 쿼리 실행한 사용자 계정
* Query_time : 쿼리 실행 시간
* Lock_time : 테이블 락 대기 시간, 0이 아니라고 잠금이 있었다는 것은 아니다. 매우 작으면 무시 가능
* Rows_examined : 쿼리 처리를 위해 몇 건의 레코드를 접근했는지를 의미


### 4.4.3.1 슬로우 쿼리 통계

![[Pasted image 20240522023818.png]]

분석 결과의 최상단에 표시
실행 시간(Exec time), 잠금 대기 시간(Lock time) 등에 최소/최대/평균 표시


### 4.4.3.2 실행 빈도 및 누적 실행 시간순 랭킹

![[Pasted image 20240522023911.png]]

각 쿼리 별 응답 시간, 실행 횟수 보여줌




### 4.4.3.3 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보

![[Pasted image 20240522024001.png]]


쿼리 ID별 쿼리를 쿼리 랭킹에 표시된 순서대로 자세한 내용을 보여줌
