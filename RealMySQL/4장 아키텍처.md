```table-of-contents
```

# 4.1 MySQL 엔진 아키텍처

MySQL 서버는 다른 DBMS에 비해 독특한 편
사용자 입장에서는 별 차이 못 느낄 수 있으나
독특한 구조로 다른 DBMS와 다르게 엄청난 혜택을 누릴 수가 있음!
반면에 다른 DBMS에서는 문제되지 않을 게 문제되기도 함(...)

## 4.1.1  MySQL의 전체 구조
![[Pasted image 20240515022551.png]]

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분!



### 4.1.1.1 MySQL 엔진
(커넥션 핸들러) 클라이언트로부터 접속 및 쿼리 요청
(옵티마이저) SQL 파서, 전처리기, 쿼리 최적화

### 4.1.1.2 스토드 스레드
MyISAM은 별로 해당사항이 없지만 InnoDB는 여러 작업이 백그라운드로 처리
* 인서트 버퍼(insert buffer)를 병합하는 스레드
* 로그를 디스크로 병합하는 스레드
* InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
* 데이터를 버퍼로 읽어 오는 스레드
* 잠금이나 데드락을 모니터링 하는 스레드

데이터 쓰기/읽기 스레드 개수 2개 이상 지정 가능
innodb_write_io_threads, innodb_read_io_thread으로 지정

데이터 쓰기는 지연될 수 있음,
데이터 읽기는 지연될 수 없음. (SELECT 실행하면 10분 뒤 결과 알려드림 -> 이런 건 없다)

쓰기 작업은 버퍼링해서 일괄처리, InnoDB 포함.
그러니 MyISAM은 사용자 스레드가 쓰기까지 함께 처리


## 4.1.3 메모리 할당 및 사용 구조

![[Pasted image 20240515023822.png]]

mysql이 사용하는 메모리 공간 -> 글로벌 메모리 영역 vs 로컬 메모리 영역

글로벌 메모리 : mysql 서버 시작 시 운영체제로부터 할당


### 4.1.3.1 글로벌 메모리 영역
클라이언트 스레드 수와 무관하게 1개 메모리 공간만 할당 (필요에 따라 2개 이상도 가능, 단 클라이언트 스레드 수와는 무관)

모든 스레드에 의해 공유

* 테이블 캐시
* InnoDB 버퍼 풀
* InnoDB 어댑티브 해시 인덱스
* InnoDB 리두 로그 버퍼



### 4.1.3.2 로컬 메모리 영역
= 세션 메모리 영역 = 클라이언트 메모리 영역
클라이언트 커넥션으로부터 요청을 처리하기 위해 스레드 하나씩 담당

각 클라이언트 스레드별로 독립 할당 / 절대 공유되지 않음

* 정렬 버퍼(Sort Buffer)
* 조인 버퍼
* 바이너리 로그 캐시
* 네트워크 버퍼



## 4.1.4 플러그인 스토리지 모델

![[Pasted image 20240515024623.png]]


mysql의 독특한 구조, 플러그인 모델

여러 스토리지 엔진을 플러그인 형태로 추가해서 사용함


![[Pasted image 20240515024852.png]]

거의 대부분이 MySQL 엔진 처리 영역에서 처리
마지막 데이터 읽기/쓰기만 스토리지 엔진에 의해 처리

MySQL 서버에서 mysql 엔진은 사람 역할을, 각 스토리지 엔진은 자동차 역할을,
mysql 엔진이 스토리지 엔진을 조정하기 위해 핸들러라는 걸 사용함

핸들러가 뭔지 몰라도 됨. mysql 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나
저장하도록 명령하려면 핸들러를 거처야 한다는 것만 기억하도록.



## 4.1.5 컴포넌트

MySQL 8.0 부터는 기존의 플러그인 아키텍처를 대체하기 위한 컴포넌트 아키텍처가 도입


플러그인 단점
* 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인 끼리는 불가
* 플러그인은 MysQL 서버의 변수나 함수를 직접 호출, 안전하지 않음, 캡슐화 X
* 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움

비밀번호 검증 기능 -> 기존에는 플러그인 형태로 제공됨
반면 8.0 부터는 컴포넌트로 개선


## 4.1.6 쿼리 실행 구조

![[Pasted image 20240515030547.png]]

### 4.1.6.1 쿼리 파서
사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리
이후 트리 형태의 구조로 변환
기본 문법 오류는 이 단계에서 발견 및 에러 메시지 전달


### 4.1.6.2 전처리기
파서 과정에서 만들어진 파서 트리가 쿼리 문장에 구조적 문제가 있는지 확인
각 토큰을 테이블 이름, 칼럼 이름, 내장 함수와 개체를 매핑, 존재 여부와 접근 권한 확인


### 4.1.6.3 옵티마이저
쿼리 문장을 저렴한 비용으로 가장 빨리 처리할지 결정, DBMS의 두뇌


### 4.1.6.4 실행 엔진
옵티마이저 -> 두뇌
실행엔진 / 핸들러 -> 손, 발

옵티마이저가 Group By를 처리하기 위해 임시 테이블을 사용한다고 결정했다하자
1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자 or 다른 모듈로 넘김

즉 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청 + 받은 결과를 또 다른 핸들러 요청의 입력으로 연결


### 4.1.6.5 핸들러 (스토리지 엔진)
핸들러는 mysql 서버의 가장 밑단에서 mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장 or 읽어옴
myisam 테이블을 조작할 경우 핸들러가 myisam 스토리지 엔진이 됨
innodb 테이블을 조작할 경우 핸들러가 innodb 스토리지 엔진이 됨


## 4.1.7 복제
복제는 매우 중요한 역할을 담당한다. 별도의 장에서 살펴본다. 넘어간다.


## 4.1.8 쿼리 캐시
쿼리 캐시(Query Cache)는 빠른 응답을 필요로 하는 웹 기반 응용 프로그램에서 중요 역할

SQL 실행 결과를 메모리에 캐시, 동일 SQL이 실행되면 테이블을 읽지 않고 결과 반환
듣기만 해도 매우 빨라보이지만

테이블 데이터가 변경되면 이와 연관된 데이터 중 캐시에 저장된건 모두 삭제됨
심각한 동시 처리 성능을 저하 유발 + 많은 버그 원인 -> 결국 삭제



## 4.1.9 스레드 풀(Thread Pool)
서버 엔터프라이즈 에디션 -> 스레드 폴 O
커뮤니티 에디션 -> X

스레드 폴은 내부적으로 사용자 요청 처리 스레드 개수를 줄여서,
동시 처리 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 하여 서버 자원 소모를 줄이는 것이 목적

???: 스레드 풀만 설치하면 성능 두 배쯤 올라가는거 아냐? -> 예끼 이놈!
실제 스레드 풀이 눈에 띄는 성능 향상을 보여준 건 드물었다.

동시 실행 중인 스레드들을 CPU가 최대한 잘 처리하낼 수 있는 수준으로 줄여 빨리 처리하게 하는 기능이기에,
CPU 시간을 제대로 확보하지 못할 경우 오히려 쿼리가 느려지기도 함


CPU의 프로세서 친화도를 높이고 운영체제 입장에서 불필요한 컨텍스트 스위칭을 줄여 오버헤드를 낮출 수 있다


기본적으로 CPU 코어 수 많큼 스레드 그룹을 만드는데, thread_pool_size 변수로 제어
스레드 그룹의 모든 스레드가 일을 처리하고 있다면
스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지,,,
아님 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 판단해야 해

thread_stall_limit 밀리초 만큼 작업 스레드가 지금 처리 중인 작업을 끝내지 못하면 새 스레드를 추가할꺼야

즉, 모든 스레드가 모두 일하는 중일 때 새 요청이 들어와도 thread_stall_limit 시간 만큼 기다려야 새 요청을 처리할 수 있다는 이야기. 따라서 응답 시간에 아주 예민하다면 적절하게 낮추자. 하지만 0에 가까운 값에 설정하는 건 권장하지 않아. 0에 가깝다면 스레드 풀을 사용하지 않는 편이 나을 것이기에.



### 4.1.10
