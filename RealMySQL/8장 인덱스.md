```table-of-contents
```

인덱스는 DB 쿼리 성능을 언급하면서 빼놓을 수 없는 부분이다.
이번 장에는 인덱스에 대해 알아보자.


# 8.1 디스크 읽기 방식

CPU, 메모리 등 전기적 특성 장치는 매우 빠르게 발전되었으나,
디스크는 상당히 제한적 발전을 이뤄왔다. 최근엔 SSD가 등장하긴 했지만,
여전히 데이터 저장 매체는 컴퓨터에서 가장 느린 부분인 점은 변함이 없다.

따라서, DB나 쿼리 튜닝에 어느 정도 지식을 갖춘 사용자가 절감하고 있듯이
DB 성능 튜닝은 어떻게 디스크 I/O를 줄이냐가 관건인 경우가 상당히 많다!


## 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

기계식인 HDD를 대신하기 위해 전자식 저장 매체인 #SSD (Solid State Drive)가 자주 출시되고 있다.
SSD도 기존 HDD와 같은 인터페이스(SATA, SAS)를 지원하므로 내장 디스크나 DAS 또는 SAN에 그대로 사용가능하다.

SSD의 특징
* D-Ram 보다는 느리지만 HDD보다는 훨씬 빠름
* HDD에서 데이터 저장용 플래터(원판) 제거하고 대신 메모리 장착
	* 원판을 회전시킬 필요 없음 -> 빨리 데이터 읽고 씀
* 디스크의 헤더를 움직이지 않고, 한 번에 많은 데이터를 읽는 순차 I/O 에서는 SDD가 HDD보다 약간 빠르거나 거의 비슷하기도 함
* 반면 랜덤 I/O는 훨씬 빠름
	* DBMS에서 순차 I/O는 그닥 비중이 크지 않고 랜덤 I/O가 대부분임을 생각하면 큰 장점으로 볼 수 있음
* 플래시 메모리는 전원이 공급되지 않아도 데이터가 삭제되지 않음

![[Pasted image 20240613204918.png]]
-부품별 처리 속도




## 8.1.2 랜덤 I/O와 순차 I/O


랜덤 I/O는 HDD의 플래터(원판)을 돌려 읽어야 할 데이터가 저장될 위치로 헤더 이동 후 데이터를 읽는 걸 의미
사실 순차 I/O도 이 작업은 같은데, 뭔 차이가 있을까?

![[Pasted image 20240613205328.png]]

순차 I/O는 3개 페이지 (3x16KB)를 디스크에 기록하기 위해 1번 시스템 콜을 요청 (헤더 1번 이동)
랜덤 I/O는 3번 시스템 콜을 요청함 (헤더 3번 이동)


데이터 읽기 / 쓰기 시간은 헤더를 움직여 읽고 쓸 위치로 옮기는 단계에서 결정된다.
즉, 위 예시에서 순차 I/O는 랜덤 I/O 보다 3배 빠르다 볼 수 있다.
-> 디스크 성능 = **헤더 위치 이동 없이** 얼마나 많은 데이터를 한 번에 쓰느냐에 결정!

> 오, 그러면 SSD는 원판이 없으니까 랜덤 I/O와 순차 I/O 차이가 없겠네?
> -> 아쉽게도 아니다. 여전히 랜덤 I/O는 순차 I/O에 비해 전체 스루풋(Throughput)이 떨어진다.
> 때문에 SSD 사양에도 순차와 랜덤 I/O를 구분하여 명시한다.



사실 쿼리 튜닝으로 랜덤 I/O를 순차 I/O로 바꾸는 건 좋은 것 같지만, 방법이 그리 많지 않다.
그렇다면 랜덤 I/O 자체를 줄이는 쪽으로 튜닝을 해야하는 거시다
랜덤 I/O 자체를 어떻게 줄일까?
쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선한다는 의미이다



# 8.2 인덱스란?

![[Pasted image 20240613210639.png]]


인덱스에 관련한 좋은 예시는 바로 사전의 **색인(찾아보기)** 이다.
책 내용은 데이터에 비유할 수 있을 것 같고,
책의 찾아보기를 통해 페이지 번호 (레코드 주소)를 알아낼 수 있다.

단, 사전의 목차 기능을 사용하려면 미리 **정렬**이 되어 있어야 함!
ㄱㄴㄷㄹ... ㅏㅑㅓㅕ 순서로 찾을 수 있기 때문이다.
DBMS도 마찬가지로 컬럼의 값을 미리 정렬하는게 필요하다.







![[Pasted image 20240613212427.png]]

즉, 미리 정렬되어 있어야 하므로 데이터를 삽입할 때 마다 정렬하는 과정이 일어나게 된다.
INSERT, UPDATE, DELETE 속도를 제물로 바쳐 SELECT 속도를 높이는 것이다.





==**Trade - off**==
프로그래머인 당신이라면 이 쯤 되면 머릿속에 한 단어가 생각날것이다. 그렇다. trade-off다.

인덱스의 SELECT 향상이라는 장점은 매우 명확하고,
UPDATE, DELETE, INSERT 제물로 바친다는 단점도 명확하다.

즉, 인덱스를 하나 더 추가해야 할 지 말지는
1. 저장 속도를 어디까지 희생시킬 수 있냐
2. 읽기 속도를 얼마나 더 빠르게 만들어야 하냐
이 두 가지에 결정된다.



**역할별 인덱스 구분**

#Primary_key : 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스. 식별자로고도 함. NULL X 중복 X

#Secondary_index(보조키) : pk 제외한 나머지 인덱스. pk 대체가능 (때문에 대체키라고도 함)



**데이터 저장 방식(알고리즘)별 구분**
#B-Tree : 가장 일반적. 인덱스 칼럼의 값을 변형하지 않고 원래 값을 이용해 인덱싱
MySQL 서버에서는 위치 기반 검색을 위한 R-Tree도 있지만 결국 B-Tree 응용

#Hash_인덱스 : 칼럼의 값으로 해시값을 인덱싱. 매우 빠르다.
값을 변형하여 인덱싱하므로 전방(Prefix) 일치와 같이 값의 일부만 검색하거나 범위 검색 시 사용 불가
주로 메모리 기반 DB에서 사용


**중복 허용 여부에 따른 구분**
#Unique , #Non-Unique 로 구분
단순하게 보면 값이 1개만 존재하냐, 2개 이상이냐지만
옵티마이저에겐 꽤 중요사항임

동등 조건으로 검색 시 1건의 레코드만 찾고 종료하냐 vs 더 찾아야 하냐를 알려주는 효과를 내기 때문





# 8.3 B-Tree 인덱스

가장 일반적인 인덱싱 알고리즘이자 가장 먼저 도입되었고, 가장 범용적이다.
B+-Tree와 B*-Tree 등 변형 알고리즘도 존재

B-Tree에서 B는 Balanced로써, Binary-Tree(이진 트리)가 아님을 주의하자.



## 8.3.1 구조 및 특성

최상위 루트(루트 노드) : 가장 최상위에 있는 노드
리프 노드 : 가장 하위에 있는 노드
브랜치 노드 : 루트 노드와 리프 노드를 제외한 나머지 노드

인덱스와 실제 데이터가 저장된 곳은 따로 관리되며
인덱스의 리프 노드는 실제 데이터를 찾아가기 위한 주솟값을 가짐

![[Pasted image 20240613214909.png]]



인덱스 키 값은 모두 정렬되어 있으나,
데이터 파일 레코드는 정렬되어 있지 않다.

INSERT 된 순서대로 저장도 아니다. 임의 저장이다.
빈 공간이 생기면 삭제된 공간을 재활용 하기 때문.
(때문에 DELETE, UPDATE 없이 INSERT만 했다면 INSERT 순서일 수 있다)

인덱스는 키 컬럼만 가지고 있으므로, 나머지 컬럼을 읽으려면 데이터 파일을 찾아야 한다.
데이터 파일 레코드 주소는 리프 노드가 가지고 있다.



![[Pasted image 20240613215403.png]]

위 InnoDB 스토리지 엔진을 사용하는 테이블에서는 PK가 ROWID 역할을 한다.

InnoDB는 pk를 주소처럼 사용하기에 논리적인 주소를 가진다고 볼 수 있다.

때문에 인덱스를 통해 레코드를 읽는다면 데이터 파일을 바로 찾아가지 못하는데,
인덱스에서 저장된 pk를 이용해 pk 인덱스를 한 번 더 검색 후,
pk 인덱스 리프 페이지에 있는 레코드를 읽어야 한다.

즉, 데이터 레코드를 읽으려면 반드시 pk를 저장하고 있는 B-Tree를 다시 한 번 검색해야 한다
엥? 그럼 성능이 떨어지는 것 아니냐?라고 할 수 있으나, 당연하게도 장단점이 있다.
자세한건 8.8절에서 알아보자.




## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

테이블 레코드를 저장 or 변경하는 경우 인덱스 키 추가/삭제가 발생한다.


### 8.3.2.1 인덱스 키 추가

새 키 값이 B-Tree에 저장되면, 바로 인덱스에 저장될까? 스토리지 엔진에 따라 그럴수도 있고 아닐수도 있다.

B-Tree는 왜 쓰기에 비용이 많이 드나?
1. B-Tree에 저장될 때, 적절한 위치를 찾아야 함
2. 레코드 키 값과 대상 레코드의 주소 정보를 B-Tree 리프 노드에 저장
3. 리프 노드가 꽉 찼다? -> 리프 노드 분리(Split) -> 상위 브랜치 노드까지 처리 범위 확장


그럼 인덱스 추가로 INSERT나 UPDATE가 어떤 영향을 받나?
* 고려할게 많다. 테이블 칼럼 수, 칼럼 크기, 인덱스 칼럼 특성 등
* 대략 테이블에 레코드 추가 작업 비용을 1로 한다면 인덱스에 키 추가 비용은 1.5로 예측함
* 테이블 인덱스 3개 -> 레코드 추가 비용 1 + 인덱스 추가 비용 1.5 * 3 = 5.5
* 중요한 건 대부분이 CPU 처리 시간이 아닌 인덱스 읽고 쓰기하는데 걸리는 시간이란 점이다.

InnoDB에서는 이 작업을 좀 더 지능적으로 처리한다.
필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리한다.
하지만 pk나 유니크 인덱스의 경우 중복 체크가 필요하므로 즉시 B-Tree에 추가 / 삭제한다.


### 8.3.2.2 인덱스 키 삭제